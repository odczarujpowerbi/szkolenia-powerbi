01a. Gaps = 

"

<!DOCTYPE html>
<html lang='pl'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>DAX Gaps</title>
    <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 16px;
        line-height: 1.6;
        color: #333;
        background: transparent;
        padding: 20px;
    }
    
    .container {
        max-width: 900px;
        margin: 0 auto;
        background: transparent;
        padding: 40px;
    }
    
    h3 {
        font-size: 26px;
        line-height: 36px;
        font-weight: 600;
        padding-top: 14px;
        padding-bottom: 6px;
        margin-bottom: 1em;
        color: #6b1718;
        border-bottom: 2px solid #6b1718;
    }
    
    .task-description {
        font-size: 1.1em;
        margin: 20px 0;
    }
    
    .code-container {
        background: #f8f9fa;
        border: 2px solid #e1e4e8;
        border-radius: 6px;
        padding: 25px;
        margin: 30px 0;
        font-family: 'Courier New', monospace;
        font-size: 1.05em;
        line-height: 1.8;
    }
    
    .drop-zone {
        display: inline-block;
        min-width: 180px;
        height: 36px;
        background: white;
        border: 2px dashed #6b1718;
        border-radius: 4px;
        padding: 6px 12px;
        margin: 0 4px;
        vertical-align: middle;
        text-align: center;
        transition: all 0.2s;
    }
    
    .drop-zone.drag-over {
        background: #ffe6e6;
        border-color: #380c0c;
    }
    
    .drop-zone.filled {
        background: #d4edda;
        border: 2px solid #28a745;
        border-style: solid;
    }
    
    .functions-title {
        font-size: 1em;
        margin: 30px 0 15px 0;
        color: #333;
    }
    
    .function-chip {
        display: inline-block;
        background: #6b1718;
        color: white;
        padding: 10px 20px;
        margin: 8px;
        border-radius: 20px;
        cursor: grab;
        font-family: 'Courier New', monospace;
        font-size: 1em;
        font-weight: 500;
        transition: all 0.2s;
        user-select: none;
    }
    
    .function-chip:hover {
        background: #380c0c;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(107, 23, 24, 0.3);
    }
    
    .function-chip:active {
        cursor: grabbing;
    }
    
    .function-chip.used {
        opacity: 0.3;
        cursor: not-allowed;
        pointer-events: none;
    }
    
    .button-group {
        margin-top: 30px;
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    button {
        background: #6b1718;
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1.05em;
        font-weight: 600;
        transition: all 0.2s;
    }
    
    button:hover {
        background: #380c0c;
        transform: translateY(-1px);
    }
    
    button.reset-btn {
        background: #6b1718;
        padding: 8px 16px;
        font-size: 0.9em;
    }
    
    button.reset-btn:hover {
        background: #380c0c;
    }
    
    .feedback {
        margin-top: 25px;
        padding: 20px;
        border-radius: 6px;
        display: none;
        font-size: 1.05em;
    }
    
    .feedback.show {
        display: block;
        animation: slideDown 0.3s ease-out;
    }
    
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .feedback.correct {
        background: #d4edda;
        border-left: 4px solid #28a745;
        color: #155724;
    }
    
    .feedback.incorrect {
        background: #f8d7da;
        border-left: 4px solid #dc3545;
        color: #721c24;
    }
    
    .hint-box {
        background: #fafafa;
        border-left: 4px solid #ccc;
        padding: 15px;
        margin: 20px 0;
        border-radius: 4px;
        color: #121212;
        font-size: 0.95em;
    }
    
    .pagination {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin: 30px 0;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 6px;
    }
    
    .page-info {
        font-weight: 600;
        color: #6b1718;
    }
    
    .nav-button {
        background: #6b1718;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
        transition: all 0.2s;
    }
    
    .nav-button:hover:not(:disabled) {
        background: #380c0c;
        transform: translateY(-1px);
    }
    
    .nav-button:disabled {
        background: #ccc;
        cursor: not-allowed;
        opacity: 0.5;
    }
    
    .page {
        display: none;
    }
    
    .page.active {
        display: block;
    }
    </style>
</head>
<body>

<div class='pagination'>
    <button class='nav-button' id='prevBtn' onclick='prevPage()'>◄ Poprzednie</button>
    <span class='page-info'>Zadanie <span id='currentPage'>1</span> z <span id='totalPages'>6</span></span>
    <button class='nav-button' id='nextBtn' onclick='nextPage()'>Następne ►</button>
</div>

<div class='page active' data-page='1'>
<div class='container'>
    <div class='task-description'>
        <h3>Odwoływanie się do kolumn</h3>
        Jak prawidłowo odwołać się do kolumny Kwota w tabeli Sprzedaz w języku DAX?
- Sprzedaz.Kwota
- [Kwota]
- Sprzedaz[Kwota]
- Kwota
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Suma Sprzedaży = SUM(<div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>)</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        W DAX używamy nawiasów kwadratowych, a nie kropki. Format to: NazwaTabeli[NazwaKolumny].
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<div class='page' data-page='2'>
<div class='container'>
    <div class='task-description'>
        <h3>Nazwy z apostrofami</h3>
        Masz tabelę o nazwie Tabela Sprzedaży (ze spacją) i kolumnę Kwota Netto. Jak prawidłowo się do niej odwołać?
- Tabela Sprzedaży[Kwota Netto]
- Tabela z apostrofem[Kwota Netto]
- Tabela i cudzysłów[Kwota Netto]
- [Tabela Sprzedaży].[Kwota Netto]
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Suma = SUM(<div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>)</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        Gdy nazwa zawiera spacje, musisz ją ująć w specjalne znaki. W DAX używamy apostrofów, nie cudzysłowów.
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<div class='page' data-page='3'>
<div class='container'>
    <div class='task-description'>
        <h3>Funkcja agregująca SUM</h3>
        Chcesz obliczyć sumę wszystkich wartości w kolumnie Kwota z tabeli Sprzedaz. Która funkcja jest odpowiednia?
- AVERAGE
- SUM
- COUNT
- SUMX
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Suma Sprzedaży = <div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>(Sprzedaz[Kwota])</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        Szukasz podstawowej funkcji agregującej, której nazwa w języku angielskim oznacza suma.
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<div class='page' data-page='4'>
<div class='container'>
    <div class='task-description'>
        <h3>Funkcja IF</h3>
        Chcesz utworzyć kategorię sprzedaży: jeśli kwota > 1000, to Wysoka, w przeciwnym razie Niska. Jak uzupełnić formułę?
- IF, THEN, ELSE
- IF, wartość_prawda, wartość_fałsz
- CASE, WHEN, ELSE
- SWITCH, TRUE, FALSE
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Kategoria =</div>
        <div><div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>(</div>
        <div>    Sprzedaz[Kwota] > 1000,</div>
        <div>    <div class='drop-zone' data-slot='1' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>,</div>
        <div>    <div class='drop-zone' data-slot='2' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div></div>
        <div>)</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        W DAX funkcja warunkowa to po prostu IF z trzema parametrami: warunek, co zwrócić gdy prawda, co zwrócić gdy fałsz.
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<div class='page' data-page='5'>
<div class='container'>
    <div class='task-description'>
        <h3>Funkcja SUMX</h3>
        Chcesz obliczyć sumę wartości zamówień (Ilość × Cena) dla każdego wiersza. Którą funkcję powinieneś użyć?
- SUM
- SUMX
- CALCULATE
- TOTALX
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Suma Wartości =</div>
        <div><div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div>(</div>
        <div>    Sprzedaz,</div>
        <div>    Sprzedaz[Ilość] * Sprzedaz[Cena]</div>
        <div>)</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        Potrzebujesz funkcji iteracyjnej (z końcówką X), która sumuje wyniki obliczeń dla każdego wiersza.
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<div class='page' data-page='6'>
<div class='container'>
    <div class='task-description'>
        <h3>Operator łączenia tekstów</h3>
        Chcesz połączyć imię i nazwisko klienta ze spacją pomiędzy. Jaki operator użyć?
- Plus
- Ampersand
- Podwójny pipe
- CONCAT
    </div>

    <div>
    </div>

    <div class='code-container'>
        <div>Pełna Nazwa =</div>
        <div>Klienci[Imię] <div class='drop-zone' data-slot='0' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div> spacja <div class='drop-zone' data-slot='1' ondrop='drop(event)' ondragover='allowDrop(event)' ondragleave='dragLeave(event)'></div> Klienci[Nazwisko]</div>
    </div>

    <div class='button-group'>
        <button onclick='checkSolution()'>Sprawdź rozwiązanie</button>
        <button class='reset-btn' onclick='resetTask()'>Reset</button>
    </div>

    <div class='hint-box'>
        Szukasz operatora (pojedynczy znak), który w wielu językach programowania służy do łączenia tekstów. To ten sam znak co ampersand.
    </div>

    <div class='feedback' id='feedback'></div>
</div>
</div>

<script>
    let currentPage = 1;
    const totalPages = 6;
    const slotsPerPage = [1, 1, 1, 3, 1, 2];
    let slots = new Array(slotsPerPage[0]).fill('');
    const correctSolutions = [['Sprzedaz[Kwota]'], ['Tabela z apostrofem[Kwota Netto]'], ['SUM'], ['IF', 'Wysoka', 'Niska'], ['SUMX'], ['Ampersand', 'Ampersand']];
    const correctFeedback = ['\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nW DAX zawsze odwo\u0142ujesz si\u0119 do kolumn poprzez nazw\u0119 tabeli i nazw\u0119 kolumny w nawiasach kwadratowych: Tabela[Kolumna]. To zapobiega niejednoznaczno\u015bci gdy masz kolumny o tych samych nazwach w r\u00f3\u017cnych tabelach.', '\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nGdy nazwa tabeli lub kolumny zawiera spacje, znaki specjalne lub polskie znaki, musisz uj\u0105\u0107 j\u0105 w apostrofy. Poprawna sk\u0142adnia to: nazwa z apostrofem. Nazwa kolumny w tym przypadku nie wymaga apostrof\u00f3w, bo jest ju\u017c w nawiasach kwadratowych.', '\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nFunkcja SUM() sumuje wszystkie warto\u015bci w kolumnie. Pomija warto\u015bci puste (BLANK) i uwzgl\u0119dnia aktualny kontekst filtrowania. To podstawowa funkcja agreguj\u0105ca w DAX.', '\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nFunkcja IF() w DAX ma sk\u0142adni\u0119: IF(warunek, warto\u015b\u0107_je\u015bli_prawda, warto\u015b\u0107_je\u015bli_fa\u0142sz). W tym przypadku: IF(Sprzedaz[Kwota] > 1000, Wysoka, Niska). Warto\u015bci tekstowe mog\u0105 by\u0107 przekazywane jako parametry.', '\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nSUMX() to funkcja iteracyjna, kt\u00f3ra dla ka\u017cdego wiersza tabeli oblicza wyra\u017cenie, a potem sumuje wyniki. Sk\u0142adnia: SUMX(tabela, wyra\u017cenie). W tym przypadku dla ka\u017cdego wiersza mno\u017cy Ilo\u015b\u0107 \u00d7 Cena, a nast\u0119pnie sumuje wszystkie wyniki.', '\u2705 **Brawo! Rozwi\u0105zanie poprawne!**\nOperator ampersand w DAX s\u0142u\u017cy do \u0142\u0105czenia (konkatenacji) tekst\u00f3w. Poprawna sk\u0142adnia: Klienci[Imi\u0119] & spacja & Klienci[Nazwisko]. Mo\u017cesz \u0142\u0105czy\u0107 dowoln\u0105 liczb\u0119 element\u00f3w tekstowych u\u017cywaj\u0105c tego operatora.'];
    const incorrectFeedback = [{'Sprzedaz.Kwota': '\u274c **Niepoprawne!**\nW DAX nie u\u017cywamy kropki do odwo\u0142ywania si\u0119 do kolumn (to sk\u0142adnia SQL). W DAX kolumny ujmujemy w nawiasy kwadratowe: Tabela[Kolumna].', '[Kwota]': '\u274c **Niepoprawne!**\nSama nazwa kolumny w nawiasach kwadratowych [Kwota] to sk\u0142adnia dla miar, nie kolumn. Do kolumn zawsze dodajemy nazw\u0119 tabeli: Tabela[Kolumna].'}, {'Tabela Sprzeda\u017cy[Kwota Netto]': '\u274c **Niepoprawne!**\nBez apostrof\u00f3w DAX nie rozpozna, \u017ce Tabela Sprzeda\u017cy to jedna nazwa. Spacja powoduje b\u0142\u0105d sk\u0142adniowy. Musisz u\u017cy\u0107 apostrof\u00f3w wok\u00f3\u0142 nazwy ze spacjami.', 'Tabela i cudzys\u0142\u00f3w[Kwota Netto]': '\u274c **Niepoprawne!**\nW DAX do ujmowania nazw ze spacjami u\u017cywamy apostrof\u00f3w, a nie cudzys\u0142ow\u00f3w. Cudzys\u0142owy s\u0142u\u017c\u0105 do definiowania warto\u015bci tekstowych.'}, {'AVERAGE': '\u274c **Niepoprawne!**\nAVERAGE() oblicza \u015bredni\u0105 arytmetyczn\u0105, a nie sum\u0119. Do sumowania warto\u015bci w kolumnie u\u017cywamy funkcji SUM().', 'COUNT': '\u274c **Niepoprawne!**\nCOUNT() liczy ile jest niepustych warto\u015bci numerycznych w kolumnie, ale nie sumuje ich. Do sumowania u\u017cywamy SUM().', 'SUMX': '\u274c **Niepoprawne!**\nSUMX() to funkcja iteracyjna, kt\u00f3ra wymaga dw\u00f3ch argument\u00f3w: tabeli i wyra\u017cenia do obliczenia dla ka\u017cdego wiersza. Do prostego sumowania kolumny wystarczy SUM().'}, {'IF, THEN, ELSE': '\u274c **Niepoprawne!**\nW DAX nie u\u017cywamy s\u0142\u00f3w kluczowych THEN i ELSE. Funkcja IF przyjmuje trzy parametry oddzielone przecinkami (lub \u015brednikami w polskiej wersji): warunek, warto\u015b\u0107 dla prawdy, warto\u015b\u0107 dla fa\u0142szu.', 'CASE, WHEN, ELSE': '\u274c **Niepoprawne!**\nTo sk\u0142adnia SQL, nie DAX. W DAX u\u017cywamy funkcji IF() lub SWITCH() do wyra\u017ce\u0144 warunkowych.'}, {'SUM': '\u274c **Niepoprawne!**\nSUM() sumuje warto\u015bci w pojedynczej kolumnie, ale nie mo\u017ce wykona\u0107 oblicze\u0144 na wielu kolumnach jednocze\u015bnie (jak Ilo\u015b\u0107 \u00d7 Cena). Do tego potrzebujesz funkcji iteracyjnej SUMX().', 'CALCULATE': '\u274c **Niepoprawne!**\nCALCULATE() s\u0142u\u017cy do modyfikowania kontekstu filtr\u00f3w, nie do iteracyjnych oblicze\u0144 wiersz po wierszu. Do obliczenia sumy wyra\u017cenia dla ka\u017cdego wiersza u\u017cywamy SUMX().', 'TOTALX': '\u274c **Niepoprawne!**\nNie ma funkcji TOTALX() w DAX. Funkcje iteracyjne to: SUMX(), AVERAGEX(), COUNTX(), MINX(), MAXX().'}, {'Plus': '\u274c **Niepoprawne!**\nOperator plus w DAX s\u0142u\u017cy do dodawania liczb, nie do \u0142\u0105czenia tekst\u00f3w. Do konkatenacji tekst\u00f3w u\u017cywamy operatora ampersand.', 'Podw\u00f3jny pipe': '\u274c **Niepoprawne!**\nOperator podw\u00f3jny pipe w DAX to logiczny operator OR (lub), nie s\u0142u\u017cy do \u0142\u0105czenia tekst\u00f3w. Do konkatenacji u\u017cywamy ampersand.', 'CONCAT': '\u274c **Niepoprawne!**\nCONCAT to funkcja (nie operator), a konkretnie CONCATENATE(). W tym zadaniu szukamy operatora. Operator do \u0142\u0105czenia tekst\u00f3w to ampersand.'}];

    function drag(event) {
            event.dataTransfer.setData('function', event.target.getAttribute('data-function'));
        }
    
        function allowDrop(event) {
            event.preventDefault();
            event.target.classList.add('drag-over');
        }
    
        function dragLeave(event) {
            event.target.classList.remove('drag-over');
        }
    
        function drop(event) {
            event.preventDefault();
            event.target.classList.remove('drag-over');
    
            const functionName = event.dataTransfer.getData('function');
            const slotIndex = parseInt(event.target.getAttribute('data-slot'));
    
            const activePage = document.querySelector('.page.active');
            if (!activePage) return;
    
            if (slots[slotIndex]) {
                const chips = activePage.querySelectorAll('.function-chip');
                for (let i = 0; i < chips.length; i++) {
                    if (chips[i].getAttribute('data-function') === slots[slotIndex]) {
                        chips[i].classList.remove('used');
                        break;
                    }
                }
            }
    
            slots[slotIndex] = functionName;
            event.target.textContent = functionName;
            event.target.classList.add('filled');
    
            const chips = activePage.querySelectorAll('.function-chip');
            for (let i = 0; i < chips.length; i++) {
                if (chips[i].getAttribute('data-function') === functionName) {
                    chips[i].classList.add('used');
                    break;
                }
            }
    
            const feedback = activePage.querySelector('.feedback');
            if (feedback) {
                feedback.classList.remove('show');
            }
        }
    
        function checkSolution() {
            const activePage = document.querySelector('.page.active');
            if (!activePage) return;
    
            const feedback = activePage.querySelector('.feedback');
            if (!feedback) return;
    
            if (slots.includes('')) {
                feedback.className = 'feedback show incorrect';
                feedback.innerHTML = 'Niekompletne! Musisz wypełnić wszystkie miejsca w kodzie.';
                return;
            }
    
            const currentPageNum = parseInt(activePage.getAttribute('data-page'));
            const pageIndex = currentPageNum - 1;
            const isCorrect = checkCurrentPageSolution(pageIndex);
    
            if (isCorrect) {
                feedback.className = 'feedback show correct';
                feedback.innerHTML = correctFeedback[pageIndex];
            } else {
                const userAnswer = slots.join(',');
                const incorrectMessages = incorrectFeedback[pageIndex];
    
                for (const pattern in incorrectMessages) {
                    if (pattern === userAnswer) {
                        feedback.className = 'feedback show incorrect';
                        feedback.innerHTML = incorrectMessages[pattern];
                        return;
                    }
    
                    if (pattern.includes('*')) {
                        const regexPattern = '^' + pattern.replace(/\*/g, '.*') + '$';
                        const regex = new RegExp(regexPattern);
                        if (regex.test(userAnswer)) {
                            feedback.className = 'feedback show incorrect';
                            feedback.innerHTML = incorrectMessages[pattern];
                            return;
                        }
                    }
                }
    
                const defaultMessage = incorrectMessages['default'];
                feedback.className = 'feedback show incorrect';
                feedback.innerHTML = defaultMessage || '❌ <strong>Niepoprawne rozwiązanie.</strong> Spróbuj ponownie!';
            }
        }
    
        function checkCurrentPageSolution(pageIndex) {
            const solution = correctSolutions[pageIndex];
            for (let i = 0; i < solution.length; i++) {
                if (slots[i] !== solution[i]) {
                    return false;
                }
            }
            return true;
        }
    
        function resetTask() {
            slots.fill('');
    
            const activePage = document.querySelector('.page.active');
            if (!activePage) return;
    
            const zones = activePage.querySelectorAll('.drop-zone');
            for (let i = 0; i < zones.length; i++) {
                zones[i].textContent = '';
                zones[i].classList.remove('filled');
            }
    
            const chips = activePage.querySelectorAll('.function-chip');
            for (let i = 0; i < chips.length; i++) {
                chips[i].classList.remove('used');
            }
    
            const feedback = activePage.querySelector('.feedback');
            if (feedback) {
                feedback.classList.remove('show');
            }
        }
    
        function showPage(pageNumber) {
            const pages = document.querySelectorAll('.page');
            for (let i = 0; i < pages.length; i++) {
                pages[i].classList.remove('active');
            }
    
            for (let i = 0; i < pages.length; i++) {
                if (parseInt(pages[i].getAttribute('data-page')) === pageNumber) {
                    pages[i].classList.add('active');
                    break;
                }
            }
    
            currentPage = pageNumber;
            const pageIndex = currentPage - 1;
            document.getElementById('currentPage').textContent = currentPage;
    
            document.getElementById('prevBtn').disabled = (currentPage === 1);
            document.getElementById('nextBtn').disabled = (currentPage === totalPages);
    
            slots = new Array(slotsPerPage[pageIndex]).fill('');
    
            resetTask();
        }
    
        function nextPage() {
            if (currentPage < totalPages) {
                showPage(currentPage + 1);
            }
        }
    
        function prevPage() {
            if (currentPage > 1) {
                showPage(currentPage - 1);
            }
        }
    
        document.addEventListener('DOMContentLoaded', function() {
            showPage(1);
        });
</script>

</body>
</html>

"
