# Funkcje filtrujące w DAX

## Wprowadzenie do funkcji filtrujących

W poprzednim rozdziale poznaliśmy funkcję CALCULATE, która pozwala modyfikować kontekst filtrów. Teraz czas na zaawansowane funkcje, które dają jeszcze większą kontrolę nad filtrowaniem danych.

Funkcje filtrujące to narzędzia, które pozwalają:
- **Usuwać** filtry selektywnie lub całkowicie
- **Zachowywać** wybrane filtry
- **Modyfikować** zakres działania filtrów

---

## ALL() - usunięcie wszystkich filtrów

Funkcja `ALL()` zwraca tabelę zawierającą wszystkie wiersze z określonej tabeli lub kolumny, **ignorując wszystkie filtry**.

### Składnia

```dax
ALL(<tabela>)
ALL(<tabela>[<kolumna>])
```

### Przykład 1: ALL() na kolumnie

```dax
Total Revenue All Categories =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALL(fDemo[Category])
)
```

**Co się dzieje?**
- Nawet jeśli użytkownik wybrał kategorię "Electronics" w slicerze, ta miara obliczy przychód dla **wszystkich** kategorii.
- Filtr na `Category` zostaje zignorowany.

### Przykład 2: ALL() na całej tabeli

```dax
Total Revenue All Data =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALL(fDemo)
)
```

**Co się dzieje?**
- Ignoruje **wszystkie** filtry na tabeli fDemo (Category, Segment, Product, itd.)
- Oblicza przychód ze wszystkich wierszy tabeli

### Praktyczne zastosowanie: Udział procentowy

```dax
Revenue % of Total =
DIVIDE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    CALCULATE(
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
        ALL(fDemo[Category])
    )
)
```

**Przykład obliczeń:**
- Electronics: przychód = 1200, całkowity przychód = 5000
- Wynik: 1200 / 5000 = 24%

---

## REMOVEFILTERS() - nowoczesna alternatywa dla ALL()

`REMOVEFILTERS()` jest nowszą i bardziej czytelną funkcją do usuwania filtrów.

### Składnia

```dax
REMOVEFILTERS(<tabela>)
REMOVEFILTERS(<tabela>[<kolumna>])
```

### Przykład 1: Usunięcie filtru z kolumny

```dax
Total Revenue All Categories =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    REMOVEFILTERS(fDemo[Category])
)
```

**Identyczny efekt jak `ALL(fDemo[Category])`**, ale bardziej czytelny.

### Przykład 2: Usunięcie wszystkich filtrów

```dax
Grand Total Revenue =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    REMOVEFILTERS()
)
```

**Co się dzieje?**
- Usuwa **wszystkie** filtry z **wszystkich** tabel
- Zwraca całkowitą sumę bez żadnych ograniczeń

### Różnica między ALL() a REMOVEFILTERS()

| Cecha | ALL() | REMOVEFILTERS() |
|-------|-------|-----------------|
| **Zwracana wartość** | Tabela ze wszystkimi wartościami | Nie zwraca wartości (tylko usuwa filtry) |
| **Czytelność** | Mniejsza | Większa |
| **Zalecenie** | Używaj gdy potrzebujesz tabeli | **Zalecane** do usuwania filtrów |

**Rekomendacja:** Używaj `REMOVEFILTERS()` do usuwania filtrów w funkcji CALCULATE - kod będzie bardziej zrozumiały.

---

## ALLSELECTED() - zachowanie kontekstu wizualnego

`ALLSELECTED()` usuwa filtry z kolumn i wierszy wizualizacji, ale **zachowuje filtry zewnętrzne** (slicery, filtry strony, filtry raportu).

### Składnia

```dax
ALLSELECTED(<tabela>)
ALLSELECTED(<tabela>[<kolumna>])
```

### Różnica między ALL() a ALLSELECTED()

**ALL()** - ignoruje wszystkie filtry, nawet slicery
**ALLSELECTED()** - ignoruje filtry wewnątrz wizualizacji, ale respektuje slicery i filtry zewnętrzne

### Przykład: Procent w kontekście slicer

Załóżmy tabelę z Category na wierszach:

```dax
Revenue % of Visible Total =
DIVIDE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    CALCULATE(
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
        ALLSELECTED(fDemo[Category])
    )
)
```

**Scenariusz:**
- **Bez slicer**: Suma w mianowniku = przychód ze wszystkich kategorii (100%)
- **Ze slicerem (Segment = "Retail")**: Suma w mianowniku = przychód tylko z segmentu Retail

**Dlaczego to przydatne?**
- Użytkownik może filtrować dane slicerem, a procenty będą liczone względem widocznych danych
- Bardziej intuicyjne zachowanie w raportach

### Przykład wizualizacji

```
Tabela (bez slicer):
+--------------+---------+--------+
| Category     | Revenue | % of Total |
+--------------+---------+--------+
| Electronics  | 1200    | 24%    |  <- 1200 / 5000
| Home         | 800     | 16%    |  <- 800 / 5000
| Garden       | 600     | 12%    |  <- 600 / 5000
| ...          | ...     | ...    |
+--------------+---------+--------+

Tabela (slicer: Segment = "Retail"):
+--------------+---------+--------+
| Category     | Revenue | % of Total |
+--------------+---------+--------+
| Electronics  | 500     | 40%    |  <- 500 / 1250 (tylko Retail)
| Home         | 400     | 32%    |  <- 400 / 1250
| Garden       | 350     | 28%    |  <- 350 / 1250
+--------------+---------+--------+
```

---

## ALLEXCEPT() - zachowanie wybranych filtrów

`ALLEXCEPT()` usuwa wszystkie filtry z tabeli **OPRÓCZ** wskazanych kolumn.

### Składnia

```dax
ALLEXCEPT(<tabela>, <kolumna1>, <kolumna2>, ...)
```

### Przykład 1: Zachowanie jednego filtru

```dax
Revenue All Except Category =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLEXCEPT(fDemo, fDemo[Category])
)
```

**Co się dzieje?**
- Usuwa filtry z **wszystkich** kolumn tabeli fDemo (Segment, Product, Discount, itd.)
- **Zachowuje** filtr na kolumnie `Category`

### Przykład 2: Zachowanie wielu filtrów

```dax
Revenue All Except Category and Segment =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLEXCEPT(fDemo, fDemo[Category], fDemo[Segment])
)
```

**Co się dzieje?**
- Usuwa filtry z wszystkich kolumn **oprócz** `Category` i `Segment`
- Przydatne gdy chcesz zachować kontekst dla kilku wymiarów

### Praktyczne zastosowanie: Total per Category

```dax
Category Total =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLEXCEPT(fDemo, fDemo[Category])
)
```

**Przykład:**
```
Tabela: Category × Product
+--------------+----------+---------+----------------+
| Category     | Product  | Revenue | Category Total |
+--------------+----------+---------+----------------+
| Electronics  | A        | 200     | 1200           |
| Electronics  | B        | 150     | 1200           |
| Electronics  | C        | 240     | 1200           |
| Electronics  | D        | 610     | 1200           |
| Home         | E        | 250     | 800            |
| Home         | F        | 120     | 800            |
| ...          | ...      | ...     | ...            |
+--------------+----------+---------+----------------+
```

Miara `Category Total` ignoruje filtr na `Product`, ale zachowuje filtr na `Category`.

---

## KEEPFILTERS() - łączenie filtrów zamiast nadpisywania

Domyślnie filtry w funkcji CALCULATE **nadpisują** istniejące filtry. `KEEPFILTERS()` powoduje **łączenie** filtrów (AND).

### Składnia

```dax
KEEPFILTERS(<filtr>)
```

### Przykład: Różnica między nadpisywaniem a łączeniem

#### Bez KEEPFILTERS (nadpisywanie):

```dax
Revenue Electronics =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    fDemo[Category] = "Electronics"
)
```

**Scenariusz:**
- Użytkownik wybiera w slicerze: Category = "Home"
- CALCULATE **nadpisuje** filtr: zmienia "Home" na "Electronics"
- Wynik: Przychód z Electronics (ignoruje wybór użytkownika)

#### Z KEEPFILTERS (łączenie):

```dax
Revenue Electronics (If Selected) =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    KEEPFILTERS(fDemo[Category] = "Electronics")
)
```

**Scenariusz:**
- Użytkownik wybiera w slicerze: Category = "Home"
- CALCULATE **łączy** filtry: "Home" AND "Electronics"
- Wynik: 0 (nie ma produktów, które są jednocześnie Home i Electronics)

**Scenariusz 2:**
- Użytkownik wybiera w slicerze: Category = "Electronics"
- CALCULATE **łączy** filtry: "Electronics" AND "Electronics"
- Wynik: Przychód z Electronics (filtry się zgadzają)

### Praktyczne zastosowanie

`KEEPFILTERS()` jest przydatne, gdy chcesz:
- **Zawęzić** istniejący filtr zamiast go nadpisać
- Upewnić się, że miara działa tylko w określonym kontekście

**Przykład: Rabat tylko dla wysokich cen**

```dax
Discount High Price Products =
CALCULATE(
    SUM(fDemo[Discount]),
    KEEPFILTERS(fDemo[Price] >= 100)
)
```

**Co się dzieje?**
- Jeśli użytkownik wybrał produkty A, B, C
- Miara obliczy rabat tylko dla tych produktów, które **dodatkowo** mają cenę >= 100
- Filtr użytkownika jest **zachowany** i **łączony** z naszym warunkiem

---

## Porównanie funkcji filtrujących

| Funkcja | Co robi | Kiedy używać |
|---------|---------|--------------|
| **ALL()** | Usuwa wszystkie filtry (zwraca tabelę) | Gdy potrzebujesz pełnej tabeli lub chcesz zignorować wszystkie filtry |
| **REMOVEFILTERS()** | Usuwa filtry (nie zwraca tabeli) | **Preferowane** do usuwania filtrów w CALCULATE |
| **ALLSELECTED()** | Usuwa filtry wewnętrzne, zachowuje zewnętrzne (slicery) | Procenty względem widocznych danych |
| **ALLEXCEPT()** | Usuwa wszystkie filtry oprócz wskazanych | Zachowanie kontekstu dla wybranych wymiarów |
| **KEEPFILTERS()** | Łączy filtry zamiast nadpisywać | Zawężanie istniejących filtrów |

---

## Praktyczne przykłady połączenia funkcji

### Przykład 1: Udział w kategorii (% of category)

```dax
% of Category =
VAR CurrentRevenue = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
VAR CategoryRevenue =
    CALCULATE(
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
        ALLEXCEPT(fDemo, fDemo[Category])
    )
RETURN
DIVIDE(CurrentRevenue, CategoryRevenue)
```

**Co się dzieje?**
1. Oblicz przychód w bieżącym kontekście (np. Electronics + Product A)
2. Oblicz przychód dla całej kategorii (np. wszystkie produkty Electronics)
3. Podziel: przychód produktu A / przychód całej kategorii Electronics

### Przykład 2: Top 3 produkty w kategorii

```dax
Top 3 Products in Category =
VAR CurrentProduct = SELECTEDVALUE(fDemo[Product])
VAR ProductRank =
    RANKX(
        ALLEXCEPT(fDemo, fDemo[Category]),
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
    )
RETURN
IF(ProductRank <= 3, "Top 3", "Other")
```

**Co się dzieje?**
1. Dla każdego produktu oblicz ranking w obrębie kategorii
2. Jeśli ranking <= 3, oznacz jako "Top 3"
3. Użyj w wizualizacji do wyróżnienia najlepszych produktów

### Przykład 3: Dynamiczny total z ALLSELECTED

```dax
Revenue vs Visible Total =
VAR CurrentRevenue = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
VAR VisibleTotal =
    CALCULATE(
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
        ALLSELECTED()
    )
RETURN
CurrentRevenue & " / " & VisibleTotal
```

**Wynik:**
- Bez slicerów: "1200 / 5000"
- Ze slicerem (Segment = "Retail"): "500 / 2500"

---

## Typowe błędy i pułapki

### Błąd 1: Mylenie ALL() z REMOVEFILTERS()

```dax
// ✗ Może być mylące
Total =
CALCULATE(
    SUM(fDemo[Price]),
    ALL(fDemo[Category])
)

// ✓ Bardziej czytelne
Total =
CALCULATE(
    SUM(fDemo[Price]),
    REMOVEFILTERS(fDemo[Category])
)
```

**Rekomendacja:** Używaj REMOVEFILTERS() dla czytelności.

### Błąd 2: ALLEXCEPT na wielu tabelach

```dax
// ✗ ALLEXCEPT działa tylko na jednej tabeli
Wrong =
CALCULATE(
    [Measure],
    ALLEXCEPT(fDemo, DimProduct[ProductName])  // Błąd!
)

// ✓ Użyj REMOVEFILTERS
Correct =
CALCULATE(
    [Measure],
    REMOVEFILTERS(fDemo),
    DimProduct[ProductName]  // Zachowaj ten filtr
)
```

### Błąd 3: Zapomnienie o KEEPFILTERS

```dax
// ✗ Nadpisuje filtr użytkownika
Problematic =
CALCULATE(
    [Revenue],
    fDemo[Category] = "Electronics"
)

// ✓ Łączy z filtrem użytkownika
Better =
CALCULATE(
    [Revenue],
    KEEPFILTERS(fDemo[Category] = "Electronics")
)
```

---

## Zaawansowane wzorce

### Wzorzec 1: Usunięcie wszystkich filtrów oprócz zewnętrznych

```dax
Total Respecting Slicers =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLSELECTED(fDemo)
)
```

**Zastosowanie:** Podsumowania respektujące slicery, ale ignorujące wiersze/kolumny wizualizacji.

### Wzorzec 2: Częściowe usuwanie filtrów

```dax
Revenue Except Product =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    REMOVEFILTERS(fDemo[Product])
)
```

**Zastosowanie:** Zobacz całkowitą sprzedaż kategorii, ignorując wybór produktu.

### Wzorzec 3: Łączenie ALLEXCEPT z dodatkowymi filtrami

```dax
High Value Sales by Category =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLEXCEPT(fDemo, fDemo[Category]),
    fDemo[Price] >= 100
)
```

**Co się dzieje?**
1. Usuń wszystkie filtry oprócz Category
2. Dodaj filtr: Price >= 100
3. Oblicz przychód

---

## Ćwiczenia praktyczne

### Ćwiczenie 1: Udział w całości

Stwórz miarę pokazującą udział każdego segmentu w całkowitej sprzedaży.

**Rozwiązanie:**
```dax
Segment % of Total =
DIVIDE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    CALCULATE(
        SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
        REMOVEFILTERS(fDemo[Segment])
    )
)
```

### Ćwiczenie 2: Total na poziomie kategorii

Stwórz miarę pokazującą total dla całej kategorii, niezależnie od wybranego produktu.

**Rozwiązanie:**
```dax
Category Total =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    ALLEXCEPT(fDemo, fDemo[Category])
)
```

### Ćwiczenie 3: Filtrowanie z zachowaniem kontekstu

Stwórz miarę pokazującą sprzedaż tylko produktów z rabatem > 10, ale respektującą filtry użytkownika.

**Rozwiązanie:**
```dax
Sales High Discount =
CALCULATE(
    SUMX(fDemo, fDemo[Price] * fDemo[Quantity]),
    KEEPFILTERS(fDemo[Discount] > 10)
)
```

---

## Podsumowanie

### Kluczowe funkcje filtrujące

✓ **REMOVEFILTERS()** - nowoczesny sposób usuwania filtrów (preferowany)
✓ **ALL()** - zwraca pełną tabelę, ignorując filtry
✓ **ALLSELECTED()** - respektuje slicery, ignoruje wiersze/kolumny wizualizacji
✓ **ALLEXCEPT()** - usuwa wszystkie filtry oprócz wskazanych
✓ **KEEPFILTERS()** - łączy filtry zamiast nadpisywać

### Kiedy używać której funkcji?

| Sytuacja | Funkcja |
|----------|---------|
| Chcę zignorować wszystkie filtry | `REMOVEFILTERS()` |
| Chcę procent względem widocznych danych | `ALLSELECTED()` |
| Chcę zachować kilka wymiarów | `ALLEXCEPT()` |
| Chcę zawęzić, nie nadpisać filtr | `KEEPFILTERS()` |
| Potrzebuję pełnej tabeli | `ALL()` |

### Najważniejsze zasady

1. **Preferuj REMOVEFILTERS() zamiast ALL()** - bardziej czytelne
2. **Używaj KEEPFILTERS() gdy ważny jest kontekst użytkownika** - unikaj nadpisywania filtrów
3. **ALLSELECTED() to klucz do intuicyjnych procentów** - respektuje slicery
4. **ALLEXCEPT() upraszcza kod** - zamiast usuwać i dodawać filtry ręcznie

### Kolejne kroki

Po opanowaniu funkcji filtrujących, możesz przejść do:
- **Time Intelligence** - analiza danych w czasie (YTD, MoM, YoY)
- **FILTER i CALCULATETABLE** - zaawansowane filtrowanie tabel
- **Relationship functions** - RELATED, RELATEDTABLE, USERELATIONSHIP
- **Virtual Relationships** - tworzenie dynamicznych relacji

Funkcje filtrujące to fundament zaawansowanej analizy w DAX. Opanowanie ich pozwala na budowanie elastycznych i wydajnych rozwiązań analitycznych!
