# Wstęp do funkcji CALCULATE

## Czym jest CALCULATE i dlaczego jest najważniejsza w DAX

**CALCULATE** to najpotężniejsza funkcja w języku DAX. Pozwala ona **modyfikować kontekst filtrów**, w którym obliczana jest miara.

### Dlaczego CALCULATE jest tak ważna?

W poprzednim rozdziale nauczyliśmy się, że miary obliczają się dynamicznie w zależności od kontekstu filtrów. Funkcja CALCULATE pozwala:

✓ **Nadpisać** istniejące filtry
✓ **Dodać** nowe filtry
✓ **Usunąć** filtry
✓ **Zmienić** sposób działania kontekstu

**Innymi słowy:** CALCULATE daje Ci pełną kontrolę nad tym, na jakich danych oblicza się Twoja miara.

### Podstawowa składnia

```dax
CALCULATE(
    <wyrażenie>,
    <filtr1>,
    <filtr2>,
    ...
)
```

- **wyrażenie** - miara lub wyrażenie do obliczenia
- **filtr1, filtr2, ...** - filtry, które mają być zastosowane

### Prosty przykład

```dax
Total Revenue = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])

Revenue Electronics Only =
CALCULATE(
    [Total Revenue],
    fDemo[Category] = "Electronics"
)
```

**Co się dzieje?**
1. Bierzemy miarę `[Total Revenue]`
2. CALCULATE wymusza filtr: `fDemo[Category] = "Electronics"`
3. Wynik: przychód **tylko** z kategorii Electronics, niezależnie od innych filtrów w raporcie

---

## Operatory logiczne i funkcje AND / OR

Często potrzebujesz zastosować wiele warunków jednocześnie. DAX oferuje kilka sposobów na łączenie warunków.

### Operatory logiczne w DAX

| Operator | Znaczenie | Przykład |
|----------|-----------|----------|
| `=` | Równe | `fDemo[Category] = "Electronics"` |
| `<>` | Różne od | `fDemo[Category] <> "Electronics"` |
| `>` | Większe niż | `fDemo[Price] > 50` |
| `>=` | Większe lub równe | `fDemo[Price] >= 50` |
| `<` | Mniejsze niż | `fDemo[Price] < 100` |
| `<=` | Mniejsze lub równe | `fDemo[Price] <= 100` |
| `&&` | Logiczne AND (i) | `fDemo[Price] > 50 && fDemo[Price] < 100` |
| `||` | Logiczne OR (lub) | `fDemo[Category] = "Electronics" || fDemo[Category] = "Home"` |
| `IN` | W zestawie wartości | `fDemo[Category] IN {"Electronics", "Home"}` |
| `&` | Łączenie tekstu | `"Category: " & fDemo[Category]` |

### Operator AND (`&&`)

Używamy gdy **wszystkie** warunki muszą być spełnione jednocześnie.

**Przykład: Sprzedaż w dni robocze**

Załóżmy, że w tabeli fDemo mamy kolumnę `DayOfWeek` (dzień tygodnia: 1 = poniedziałek, ..., 7 = niedziela).

```dax
Sales Weekdays =
CALCULATE(
    [Total Revenue],
    fDemo[DayOfWeek] >= 1 && fDemo[DayOfWeek] <= 5
)
```

**Warunek:** `DayOfWeek >= 1` **I** `DayOfWeek <= 5`

Alternatywna składnia z funkcją AND():
```dax
Sales Weekdays (Alternative) =
CALCULATE(
    [Total Revenue],
    AND(fDemo[DayOfWeek] >= 1, fDemo[DayOfWeek] <= 5)
)
```

### Operator OR (`||`)

Używamy gdy **przynajmniej jeden** z warunków musi być spełniony.

**Przykład: Sprzedaż w weekendy**

```dax
Sales Weekends =
CALCULATE(
    [Total Revenue],
    fDemo[DayOfWeek] = 6 || fDemo[DayOfWeek] = 7
)
```

**Warunek:** `DayOfWeek = 6` **LUB** `DayOfWeek = 7`

Alternatywna składnia z funkcją OR():
```dax
Sales Weekends (Alternative) =
CALCULATE(
    [Total Revenue],
    OR(fDemo[DayOfWeek] = 6, fDemo[DayOfWeek] = 7)
)
```

### Operator IN - eleganckie sprawdzanie wielu wartości

Zamiast pisać wielokrotnie OR, użyj operatora `IN`:

```dax
// ✗ Nieeleganckie
Revenue Home or Garden =
CALCULATE(
    [Total Revenue],
    fDemo[Category] = "Home" || fDemo[Category] = "Garden"
)

// ✓ Eleganckie
Revenue Home or Garden =
CALCULATE(
    [Total Revenue],
    fDemo[Category] IN {"Home", "Garden"}
)
```

**Operator IN** sprawdza, czy wartość znajduje się w podanym zestawie.

### Łączenie operatorów AND i OR

Możesz łączyć różne operatory:

```dax
High Value Electronics =
CALCULATE(
    [Total Revenue],
    fDemo[Category] = "Electronics" &&
    fDemo[Price] >= 100
)
```

**Warunek:** Kategoria = "Electronics" **I** Cena >= 100

---

## Praktyczne przykłady z CALCULATE

### Przykład 1: SELECTEDVALUE() - wartość wybranego elementu

`SELECTEDVALUE()` zwraca wartość, gdy w kontekście filtru znajduje się dokładnie jeden element. Jeśli jest więcej lub zero elementów, zwraca wartość domyślną lub BLANK().

```dax
Selected Category = SELECTEDVALUE(fDemo[Category])
```

**Kiedy użyć?**
- Tytuły dynamiczne
- Warunkowa logika bazująca na wyborze użytkownika

**Przykład: Dynamiczny tytuł tabeli**

```dax
Table Title =
IF(
    SELECTEDVALUE(fDemo[Category]) = BLANK(),
    "Sales Summary by Month",
    "Sales Summary for Category: " & SELECTEDVALUE(fDemo[Category])
)
```

**Co się dzieje?**
- Jeśli użytkownik nie wybrał żadnej kategorii (lub wybrał więcej niż jedną) → "Sales Summary by Month"
- Jeśli użytkownik wybrał jedną kategorię → "Sales Summary for Category: Electronics"

### Przykład 2: IF() - logika warunkowa

Funkcja `IF()` pozwala na wykonanie różnych obliczeń w zależności od spełnienia warunku.

```dax
IF(<warunek>, <wartość_gdy_prawda>, <wartość_gdy_fałsz>)
```

**Przykład: Kategoryzacja produktów**

Załóżmy, że chcemy oznaczyć produkty jako nieaktywne, jeśli nie były sprzedawane od 30 dni:

```dax
Product Inactive (30 days) =
IF(
    MAX(fDemo[ID]) < TODAY() - 30,  // Uwaga: To uproszczony przykład
    "Inactive",
    "Active"
)
```

**Przykład: Wykrycie wysokiego rabatu**

```dax
High Discount Flag =
IF(
    AVERAGE(fDemo[Discount]) > 10,
    "High Discount Applied",
    "Standard Discount"
)
```

### Przykład 3: ALL() i REMOVEFILTERS() - usuwanie filtrów

`ALL()` i `REMOVEFILTERS()` pozwalają na **zignorowanie** filtrów w kontekście.

#### ALL() - ignoruje filtry

```dax
Total Revenue All Categories =
CALCULATE(
    [Total Revenue],
    ALL(fDemo[Category])
)
```

**Co się dzieje?**
- Nawet jeśli użytkownik wybrał kategorię "Electronics", ta miara obliczy przychód dla **wszystkich** kategorii.

#### REMOVEFILTERS() - bardziej nowoczesna alternatywa

```dax
Total Revenue All Categories =
CALCULATE(
    [Total Revenue],
    REMOVEFILTERS(fDemo[Category])
)
```

**Różnica między ALL() a REMOVEFILTERS():**
- `ALL()` - zwraca tabelę ze wszystkimi wartościami (usuwa filtry)
- `REMOVEFILTERS()` - po prostu usuwa filtry (bardziej czytelne, zalecane)

**Przykład praktyczny: Udział w całości (% of Total)**

```dax
Revenue % of Total =
DIVIDE(
    [Total Revenue],
    CALCULATE([Total Revenue], REMOVEFILTERS(fDemo[Category]))
)
```

**Wynik:**
- Jeśli Electronics ma przychód 1000, a całkowity przychód to 5000
- Wynik: 1000 / 5000 = 20%

### Przykład 4: Podstawowe operatory arytmetyczne

DAX wspiera standardowe operatory matematyczne:

| Operator | Znaczenie | Przykład |
|----------|-----------|----------|
| `+` | Dodawanie | `fDemo[Price] + fDemo[Cost]` |
| `-` | Odejmowanie | `fDemo[Price] - fDemo[Cost]` |
| `*` | Mnożenie | `fDemo[Price] * fDemo[Quantity]` |
| `/` | Dzielenie | `fDemo[Price] / fDemo[Cost]` |

**Przykład: Obliczenie przychodu**

```dax
Total Revenue = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
```

**Przykład: Obliczenie marży**

```dax
Total Profit = SUMX(fDemo, (fDemo[Price] - fDemo[Cost]) * fDemo[Quantity])
```

**Przykład: Procent marży**

```dax
Profit Margin % =
DIVIDE(
    [Total Profit],
    [Total Revenue]
)
```

**Uwaga:** Używaj `DIVIDE()` zamiast `/` aby uniknąć błędów dzielenia przez zero.

### Przykład 5: Łączenie tekstu operatorem &

Operator `&` pozwala na łączenie tekstów.

```dax
Product Description =
"Product: " & fDemo[Product] & ", Category: " & fDemo[Category]
```

**Wynik dla pierwszego wiersza:** "Product: A, Category: Electronics"

**Przykład: Dynamiczny tytuł**

```dax
Report Title =
"Sales Report for " & SELECTEDVALUE(fDemo[Category], "All Categories")
```

**Wynik:**
- Gdy wybrano Electronics → "Sales Report for Electronics"
- Gdy nic nie wybrano → "Sales Report for All Categories"

---

## Zaawansowane przykłady miar

### Przykład 1: Liczba sprzedanych jednostek

```dax
Units Sold = SUM(fDemo[Quantity])
```

Prosta suma wszystkich ilości w kontekście filtru.

### Przykład 2: Średnia sprzedaż na segment

```dax
Avg Sales per Segment =
DIVIDE(
    [Total Revenue],
    DISTINCTCOUNT(fDemo[Segment])
)
```

**Co się dzieje?**
1. Oblicz całkowity przychód
2. Policz unikalne segmenty (Retail, Online, Wholesale)
3. Podziel przychód przez liczbę segmentów

### Przykład 3: Średnia wartość transakcji (na ID)

Załóżmy, że każdy wiersz w fDemo reprezentuje osobną transakcję:

```dax
Avg Transaction Value =
DIVIDE(
    [Total Revenue],
    DISTINCTCOUNT(fDemo[ID])
)
```

### Przykład 4: Sprzedaż tylko w dni robocze

Załóżmy, że mamy kolumnę `DayOfWeek` (1-7):

```dax
Sales Weekdays =
CALCULATE(
    [Total Revenue],
    fDemo[DayOfWeek] >= 1 && fDemo[DayOfWeek] <= 5
)
```

### Przykład 5: Sprzedaż w weekendy

```dax
Sales Weekends =
CALCULATE(
    [Total Revenue],
    fDemo[DayOfWeek] IN {6, 7}
)
```

Alternatywa z operatorem OR:
```dax
Sales Weekends =
CALCULATE(
    [Total Revenue],
    fDemo[DayOfWeek] = 6 || fDemo[DayOfWeek] = 7
)
```

### Przykład 6: Sprzedaż - wszystko oprócz napojów

```dax
Sales Non-Beverages =
CALCULATE(
    [Total Revenue],
    fDemo[Category] <> "Beverages"
)
```

**Uwaga:** Przykład zakłada, że w tabeli istnieje kategoria "Beverages". Dla fDemo można użyć:

```dax
Sales Except Home =
CALCULATE(
    [Total Revenue],
    fDemo[Category] <> "Home"
)
```

### Przykład 7: Sprzedaż tylko napojów

```dax
Sales Beverages =
CALCULATE(
    [Total Revenue],
    fDemo[Category] = "Beverages"
)
```

Dla fDemo:
```dax
Sales Home Only =
CALCULATE(
    [Total Revenue],
    fDemo[Category] = "Home"
)
```

### Przykład 8: Liczba faktur (unikalne ID)

```dax
Transaction Count = DISTINCTCOUNT(fDemo[ID])
```

### Przykład 9: Liczba wszystkich wierszy

```dax
Row Count = COUNT(fDemo[ID])
```

**Różnica:**
- `DISTINCTCOUNT()` - liczy unikalne wartości
- `COUNT()` - liczy wszystkie niepuste wartości

W przypadku tabeli fDemo, gdzie ID jest unikalne, wynik będzie identyczny.

### Przykład 10: Sprzedaż brutto

```dax
Gross Sales = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
```

### Przykład 11: Rabat całkowity

```dax
Total Discount = SUM(fDemo[Discount])
```

### Przykład 12: Sprzedaż netto (po rabacie)

Zakładając, że `Discount` jest wartością absolutną (nie procentem):

```dax
Net Sales =
SUMX(
    fDemo,
    (fDemo[Price] * fDemo[Quantity]) - fDemo[Discount]
)
```

Jeśli `Discount` jest procentem (0-100):

```dax
Net Sales =
SUMX(
    fDemo,
    fDemo[Price] * fDemo[Quantity] * (1 - fDemo[Discount] / 100)
)
```

### Przykład 13: Średnia wartość faktury

```dax
Avg Transaction Value =
DIVIDE(
    [Total Revenue],
    DISTINCTCOUNT(fDemo[ID])
)
```

### Przykład 14: Różnica między wartością a celem

Załóżmy, że mamy tabelę `Targets` z celami sprzedażowymi:

```dax
Variance vs Target = [Total Revenue] - [Target]
```

Gdzie `[Target]` to:
```dax
Target = SUM(Targets[Target])
```

### Przykład 15: Procent realizacji targetu

```dax
Target Achievement % =
DIVIDE(
    [Total Revenue],
    [Target]
) - 1
```

**Wynik:**
- 10% powyżej targetu → 0.10 (10%)
- 5% poniżej targetu → -0.05 (-5%)

Alternatywnie (bez odejmowania 1):
```dax
Target Achievement % =
DIVIDE(
    [Total Revenue],
    [Target]
)
```

**Wynik:**
- 100% realizacji → 1.00
- 110% realizacji → 1.10

### Przykład 16: Bazowanie sprzedaży na miesiącu 1

Załóżmy, że mamy kolumnę `MonthNumber`:

```dax
Indexed Sales =
DIVIDE(
    [Total Revenue],
    CALCULATE(
        [Total Revenue],
        fDemo[MonthNumber] = 1
    )
)
```

**Co się dzieje?**
1. Oblicz przychód w bieżącym kontekście (np. miesiąc 3)
2. Oblicz przychód dla miesiąca 1 (ignorując filtr miesiąca)
3. Podziel: przychód miesiąca 3 / przychód miesiąca 1

**Wynik:**
- Jeśli miesiąc 1 miał 1000, a miesiąc 3 ma 1200
- Indexed Sales = 1200 / 1000 = 1.20 (wzrost o 20%)

---

## Funkcje pomocnicze w CALCULATE

### DIVIDE() - bezpieczne dzielenie

**Problem:** Dzielenie przez zero powoduje błąd.

```dax
// ✗ Może zwrócić błąd
Bad Measure = [Revenue] / [Cost]

// ✓ Bezpieczne
Good Measure = DIVIDE([Revenue], [Cost], 0)
```

**Składnia:**
```dax
DIVIDE(<licznik>, <mianownik>, <wartość_alternatywna>)
```

- Jeśli mianownik = 0 → zwraca `wartość_alternatywna`
- Domyślnie `wartość_alternatywna` = BLANK()

### MAX() / MIN() - znajdowanie wartości ekstremalnych

```dax
Highest Price = MAX(fDemo[Price])
Lowest Price = MIN(fDemo[Price])
```

### DISTINCTCOUNT() vs COUNT()

```dax
// Liczy unikalne wartości
Unique Products = DISTINCTCOUNT(fDemo[Product])

// Liczy wszystkie niepuste wartości
Total Rows = COUNT(fDemo[ID])
```

### SUM() vs SUMX()

#### SUM() - sumuje kolumnę

```dax
Total Quantity = SUM(fDemo[Quantity])
```

#### SUMX() - iteruje po wierszach i sumuje wyrażenie

```dax
Total Revenue = SUMX(fDemo, fDemo[Price] * fDemo[Quantity])
```

**Różnica:**
- `SUM()` - sumuje gotową kolumnę
- `SUMX()` - oblicza wyrażenie dla każdego wiersza, potem sumuje

---

## Podsumowanie

### Kluczowe pojęcia

✓ **CALCULATE** to najpotężniejsza funkcja w DAX - kontroluje kontekst filtrów
✓ **Operatory logiczne** (`&&`, `||`, `IN`) pozwalają na precyzyjne filtrowanie
✓ **ALL() i REMOVEFILTERS()** usuwają filtry
✓ **IF()** pozwala na warunkową logikę
✓ **SELECTEDVALUE()** zwraca wartość wybranego elementu
✓ **DIVIDE()** bezpiecznie dzieli, unikając błędów

### Wzorce użycia CALCULATE

| Cel | Wzorzec |
|-----|---------|
| Filtrowanie do jednej wartości | `CALCULATE([Miara], Tabela[Kolumna] = "Wartość")` |
| Filtrowanie do zakresu | `CALCULATE([Miara], Tabela[Kolumna] >= X && Tabela[Kolumna] <= Y)` |
| Filtrowanie do wielu wartości | `CALCULATE([Miara], Tabela[Kolumna] IN {X, Y, Z})` |
| Usunięcie filtrów | `CALCULATE([Miara], REMOVEFILTERS(Tabela[Kolumna]))` |
| Ignorowanie wszystkich filtrów | `CALCULATE([Miara], REMOVEFILTERS())` |

### Kolejne kroki

Po opanowaniu CALCULATE, możesz przejść do:
- **Funkcje modyfikujące kontekst**: ALLSELECTED, ALLEXCEPT, KEEPFILTERS
- **Time Intelligence**: TOTALYTD, SAMEPERIODLASTYEAR, DATEADD
- **Zaawansowane wzorce**: FILTER, CALCULATETABLE, SUMMARIZE
- **Virtual Relationships**: tworzenie relacji w obliczeniach

Funkcja CALCULATE to fundament zaawansowanego DAX - opanowanie jej otwiera drzwi do niemal nieograniczonych możliwości analizy danych!
