# ALL i REMOVEFILTERS - usuwanie filtrów

### Czym jest ALL?

ALL usuwa filtry z tabeli lub kolumny. Mówisz silnikowi DAX: "zignoruj wszelkie filtry, które użytkownik (lub inne miary) nałożył na ten obiekt".

```dax
ALL(tabela)
ALL(tabela[kolumna])
ALL(tabela[kolumna1], tabela[kolumna2], ...)
```

### Podstawowy przypadek - procent od całości

Użytkownik wybiera w slicerze kategorię "Computers". Chcesz pokazać:

- Sprzedaż Computers: 400 000 zł
- Sprzedaż całkowita: 1 000 000 zł (mimo filtru!)
- Udział: 40%

```dax
Total Sales = SUM(fSales[SalesAmount])

Total Sales All Categories = 
CALCULATE(
    [Total Sales],
    ALL(dProduct[ProductCategoryName])
)

Sales % = DIVIDE([Total Sales], [Total Sales All Categories])
```

Co się dzieje:

|Kontekst użytkownika|[Total Sales]|[Total Sales All Categories]|
|---|---|---|
|Computers|400 000 zł|1 000 000 zł|
|Cameras|250 000 zł|1 000 000 zł|
|TV|350 000 zł|1 000 000 zł|

`ALL(dProduct[ProductCategoryName])` mówi: "usuń filtr z kategorii, ale zostaw inne filtry (np. na roku, kraju)".

---
### ALL na całej tabeli vs na kolumnie
- Usuwa filtr **TYLKO** z kategorii
- Filtr na kraju, roku itp. nadal działa
```dax
CALCULATE(
	[Total Sales],
	ALL(dProduct[ProductCategoryName])
)
```

-  Usuwa **WSZYSTKIE** filtry z tabeli **dProduct**
-  Kolor, marka, podkategoria - wszystko zignorowane

```dax
CALCULATE(
	[Total Sales],
	 ALL(dProduct)
 )
```

---
### REMOVEFILTERS - nowszy odpowiednik ALL

Od 2019 roku mamy `REMOVEFILTERS`, który robi dokładnie to samo co `ALL` w kontekście `CALCULATE`:

```dax
// Te dwie miary są identyczne:
CALCULATE(
	[Total Sales],
	 ALL(dProduct)
 )
CALCULATE(
	[Total Sales],
	 REMOVEFILTERS(dProduct)
)
```

Dlaczego `REMOVEFILTERS` jest lepszy?

1. Nazwa jasno mówi co robi (usuwa filtry, nie "wszystko")
2. `ALL` ma podwójne znaczenie - jako modyfikator filtra i jako funkcja tabelaryczna
3. Czytelność kodu

```dax
// ALL jako funkcja tabelaryczna (zwraca tabelę bez filtrów)
All Products Table = ALL(dProduct)

// ALL jako modyfikator w CALCULATE (usuwa filtry)
Sales Without Filter = CALCULATE([Total Sales], ALL(dProduct))

// REMOVEFILTERS - jednoznaczne, tylko modyfikator
Sales Without Filter = CALCULATE([Total Sales], REMOVEFILTERS(dProduct))
```


## ALLEXCEPT - usuń wszystko OPRÓCZ

### Problem, który rozwiązuje ALLEXCEPT

Wyobraź sobie tabelę dProduct z kolumnami: ProductKey, ProductName, ProductCategoryName, ProductSubcategoryName, BrandName, Color, UnitPrice.

Chcesz policzyć udział produktu w swojej kategorii. Potrzebujesz usunąć filtry z produktu, ale ZACHOWAĆ filtr kategorii.

```dax
// Podejście 1: wymieniasz wszystko co chcesz usunąć
Sales Category Total v1 =
CALCULATE(
    [Total Sales],
    ALL(
        dProduct[ProductKey],
        dProduct[ProductName],
        dProduct[ProductSubcategoryName],
        dProduct[BrandName],
        dProduct[Color],
        dProduct[UnitPrice]
    )
)
```

Działa, ale jest nieczytelne i łatwo o pomyłkę. A co jeśli ktoś doda nową kolumnę do tabeli?

```dax
// Podejście 2: ALLEXCEPT
Sales Category Total v2 =
CALCULATE(
    [Total Sales],
    ALLEXCEPT(dProduct, dProduct[ProductCategoryName])
)
```

`ALLEXCEPT` mówi: "usuń wszystkie filtry z dProduct OPRÓCZ filtra na ProductCategoryName".

---
### Wizualizacja działania

Raport pokazuje produkty w kategorii "Computers":

|Produkt|[Total Sales]|[Sales Category Total]|Udział|
|---|---|---|---|
|Laptop A|150 000 zł|400 000 zł|37.5%|
|Laptop B|120 000 zł|400 000 zł|30.0%|
|Desktop C|130 000 zł|400 000 zł|32.5%|

Gdy użytkownik przełączy na kategorię "Cameras":

|Produkt|[Total Sales]|[Sales Category Total]|Udział|
|---|---|---|---|
|Camera X|100 000 zł|250 000 zł|40.0%|
|Camera Y|150 000 zł|250 000 zł|60.0%|

Filtr kategorii jest respektowany - total zmienia się z 400 000 na 250 000.

---
### ALLEXCEPT z wieloma kolumnami

Możesz zachować filtry na wielu kolumnach:

```dax
// Udział produktu w swojej kategorii I kraju
Sales Category Country Total =
CALCULATE(
    [Total Sales],
    ALLEXCEPT(
        dProduct,
        dProduct[ProductCategoryName]
    ),
    ALLEXCEPT(
        dGeography,
        dGeography[RegionCountryName]
    )
)
```


## ALLSELECTED - uwzględnij kontekst fragmentatora

Masz raport z tabelą pokazującą sprzedaż po kategoriach. Użytkownik wybiera w slicerze trzy kategorie: Computers, Cameras, TV. Chce widzieć udział każdej z tych trzech w ich łącznej sumie.

```dax
// Próba z ALL
Sales % with ALL =
DIVIDE(
    [Total Sales],
    CALCULATE([Total Sales], ALL(dProduct[ProductCategoryName]))
)
```

Problem: ALL usuwa WSZYSTKIE filtry z kategorii - czyli ignoruje też slicer. Mianownik to sprzedaż wszystkich kategorii w bazie (także Audio, Games, itd.), nie tylko trzech wybranych.

|Kategoria|[Total Sales]|Mianownik (ALL)|%|
|---|---|---|---|
|Computers|400 000 zł|2 000 000 zł|20%|
|Cameras|250 000 zł|2 000 000 zł|12.5%|
|TV|350 000 zł|2 000 000 zł|17.5%|
|**Suma**|**1 000 000 zł**||**50%** ← nie sumuje się do 100%!|

---
### ALLSELECTED - rozwiązanie

ALLSELECTED usuwa filtry z wizualizacji (tabeli, wykresu), ale ZACHOWUJE filtry zewnętrzne (slicery, filtry strony/raportu).

```dax
Sales % with ALLSELECTED =
DIVIDE(
    [Total Sales],
    CALCULATE([Total Sales], ALLSELECTED(dProduct[ProductCategoryName]))
)
```

Teraz mianownik to suma tylko dla kategorii wybranych w slicerze:

|Kategoria|[Total Sales]|Mianownik (ALLSELECTED)|%|
|---|---|---|---|
|Computers|400 000 zł|1 000 000 zł|40%|
|Cameras|250 000 zł|1 000 000 zł|25%|
|TV|350 000 zł|1 000 000 zł|35%|
|**Suma**|**1 000 000 zł**||**100%** ✓|

### ALLSELECTED bez argumentów

Możesz użyć ALLSELECTED() bez podawania tabeli/kolumny - wtedy usuwa filtry wizualizacji ze WSZYSTKICH tabel:

```dax
// Usuwa filtr wizualizacji tylko z kategorii
CALCULATE(
	[Total Sales],
	 ALLSELECTED(dProduct[ProductCategoryName])
 )
```


```dax
// Usuwa filtr wizualizacji ze wszystkiego (produkty, czas, geografia...)
CALCULATE(
	[Total Sales],
	 ALLSELECTED()
 )
```

---
### Porównanie ALL vs ALLSELECTED

```dax
Total Sales = SUM(fSales[SalesAmount])

// Ignoruje WSZYSTKO - zawsze pełna baza
Grand Total ALL =
CALCULATE([Total Sales], ALL(dProduct))

// Ignoruje wizualizację, respektuje slicery
Grand Total ALLSELECTED =
CALCULATE([Total Sales], ALLSELECTED(dProduct))
```

Scenariusz: Slicer = "Computers", tabela pokazuje podkategorie:

| Podkategoria | [Total Sales] | [Grand Total ALL] | [Grand Total ALLSELECTED] |
| ------------ | ------------- | ----------------- | ------------------------- |
| Laptops      | 200 000 zł    | 2 000 000 zł      | 400 000 zł                |
| Desktops     | 150 000 zł    | 2 000 000 zł      | 400 000 zł                |
| Tablets      | 50 000 zł     | 2 000 000 zł      | 400 000 zł                |
|              |               |                   |                           |

- ALL daje całą bazę (2 mln)
- ALLSELECTED daje sumę dla "Computers" (400k) - respektuje fragmentator


---
## KEEPFILTERS - zachowaj istniejące filtry

### Problem: CALCULATE nadpisuje filtry

Domyślnie filtr w CALCULATE **zastępuje** istniejący filtr na tej samej kolumnie:

```dax
Sales Computers =
CALCULATE(
    [Total Sales],
    dProduct[ProductCategoryName] = "Computers"
)
```

Co się stanie, gdy użytkownik wybierze w slicerze "Cameras"?

| Kontekst użytkownika | [Total Sales] | [Sales Computers] |
| -------------------- | ------------- | ----------------- |
| (brak filtra)        | 1 000 000 zł  | 400 000 zł        |
| Cameras              | 250 000 zł    | 400 000 zł        |
| Computers            | 400 000 zł    | 400 000 zł        |

Filtr z CALCULATE wygrywa - nadpisuje wybór użytkownika. Czasem tego chcesz, czasem nie.

---
### KEEPFILTERS - przecięcie filtrów

KEEPFILTERS mówi: "nie nadpisuj, tylko znajdź część wspólną".

```dax
Sales Computers Keep =
CALCULATE(
    [Total Sales],
    KEEPFILTERS(dProduct[ProductCategoryName] = "Computers")
)
```

Teraz:

|Kontekst użytkownika|[Sales Computers]|[Sales Computers Keep]|
|---|---|---|
|(brak filtra)|400 000 zł|400 000 zł|
|Cameras|400 000 zł|**BLANK**|
|Computers|400 000 zł|400 000 zł|

Gdy użytkownik wybiera "Cameras", KEEPFILTERS szuka przecięcia: (Cameras) ∩ (Computers) = zbiór pusty = BLANK.

---
### Praktyczny przypadek dla KEEPFILTERS

Masz raport z podziałem na segmenty klientów. Chcesz pokazać sprzedaż "Premium" tylko gdy użytkownik patrzy na segment Premium (nie na siłę):

```dax
// Bez KEEPFILTERS - zawsze pokazuje Premium, nawet gdy wybrano "Standard"
Sales Premium Wrong =
CALCULATE([Total Sales], dCustomer[Segment] = "Premium")

// Z KEEPFILTERS - pokazuje Premium tylko gdy kontekst to Premium
Sales Premium Correct =
CALCULATE([Total Sales], KEEPFILTERS(dCustomer[Segment] = "Premium"))
```

---
### Kiedy używać KEEPFILTERS?

Rzadko - ale są scenariusze:

1. Walidacja danych (pokaż wartość tylko gdy kontekst się zgadza)
2. Warunkowe KPI (np. "cel" ma sens tylko dla konkretnego regionu)
3. Unikanie "wyciekania" danych do innych kontekstów

---
## CROSSFILTER

Umożliwia tymczasową zmianę kierunku filtrowania relacji w kontekście danego wyrażenia DAX.
```d
CROSSFILTER(<columnName1>, <columnName2>, <direction>)
```
- `Both` — filtrowanie dwukierunkowe (filtry przechodzą w obu kierunkach, domyślnie jest jednokierunkowe).
- `None` — wyłącza filtrowanie między tabelami.
- `OneWay` — jednokierunkowe filtrowanie z Column1 do Column2 (domyślnie).
- `OneWayReverse` — jednokierunkowe filtrowanie z Column2 do Column1.
###### Przykład
```d
BiDi= 
	CALCULATE(
		[Distinct Count of ProductKey]
		, CROSSFILTER(FactInternetSales[ProductKey]
		, DimProduct[ProductKey]
		, Both)
	)
```

---
## USERELATIONSHIP
**USERELATIONSHIP** aktywuje nieaktywną relację między tabelami na czas trwania obliczenia. W modelu Power BI między dwiema tabelami może istnieć wiele relacji, ale tylko jedna może być aktywna domyślnie.

### Typowy scenariusz
Najczęstszy przypadek to tabela faktów z wieloma kolumnami dat powiązanymi z jedną tabelą kalendarza:
```dax
Sales
├─ OrderDate      → 'Calendar'[Date] (relacja aktywna)
├─ ShipmentDate   → 'Calendar'[Date] (relacja nieaktywna)
└─ DeliveryDate   → 'Calendar'[Date] (relacja nieaktywna)
```


## Podstawowa składnia

```dax
------- Miara używająca domyślnej relacji (OrderDate)
Sales Amount = 
    SUMX ( Sales, Sales[Quantity] * Sales[Unit Price] )

------- Miara aktywująca relację ShipmentDate
Sales Amount by Shipment = 
CALCULATE (
    SUMX ( Sales, Sales[Quantity] * Sales[Unit Price] ),
    USERELATIONSHIP ( Sales[ShipmentDate], 'Calendar'[Date] )
)

------- Miara aktywująca relację DeliveryDate
Sales Amount by Delivery = 
CALCULATE (
    SUMX ( Sales, Sales[Quantity] * Sales[Unit Price] ),
    USERELATIONSHIP ( Sales[DeliveryDate], 'Calendar'[Date] )
)
```

**Kluczowe zasady:**
- USERELATIONSHIP działa tylko wewnątrz CALCULATE lub CALCULATETABLE
- Pierwszym parametrem jest kolumna z tabeli faktów (strona "wiele")
- Drugim parametrem jest kolumna z tabeli wymiaru (strona "jeden")
- Relacja musi fizycznie istnieć w modelu (być zdefiniowana, choć nieaktywna)