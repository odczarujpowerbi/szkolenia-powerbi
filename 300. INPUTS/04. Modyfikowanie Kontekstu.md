---
type: teoria
---

# ALL i REMOVEFILTERS - usuwanie filtrów

### Czym jest ALL?

ALL usuwa filtry z tabeli lub kolumny. Mówisz silnikowi DAX: "zignoruj wszelkie filtry, które użytkownik (lub inne miary) nałożył na ten obiekt".

```dax
DAX
ALL(tabela)
ALL(tabela[kolumna])
ALL(tabela[kolumna1], tabela[kolumna2], ...)
```

### Podstawowy przypadek - procent od całości

Użytkownik wybiera w slicerze kategorię "Computers". Chcesz pokazać:

- Sprzedaż Computers: 400 000 zł
- Sprzedaż całkowita: 1 000 000 zł (mimo filtru!)
- Udział: 40%

```dax
DAX
Sprzedaż Netto = SUM(ffSprzedaż[fSprzedażAmount])

Sprzedaż Netto All Categories = 
CALCULATE(
    [Sprzedaż Netto],
    ALL(dKategorie[Kategoria])
)

fSprzedaż % = DIVIDE([Sprzedaż Netto], [Sprzedaż Netto All Categories])
```

Co się dzieje:

| Kontekst użytkownika | [Sprzedaż Netto] | [Sprzedaż Netto All Categories] |
| -------------------- | ------------- | ---------------------------- |
| Computers            | 400 000 zł    | 1 000 000 zł                 |
| Cameras              | 250 000 zł    | 1 000 000 zł                 |
| TV                   | 350 000 zł    | 1 000 000 zł                 |

`ALL(dKategorie[Kategoria])` mówi: "usuń filtr z kategorii, ale zostaw inne filtry (np. na roku, kraju)".

---
### ALL na całej tabeli vs na kolumnie
- Usuwa filtr **TYLKO** z kategorii
- Filtr na kraju, roku itp. nadal działa
```dax
DAX
CALCULATE(
	[Sprzedaż Netto],
	ALL(dKategorie[Kategoria])
)
```

-  Usuwa **WSZYSTKIE** filtry z tabeli **dKategorie**
-  Kolor, marka, podKategorie - wszystko zignorowane

```dax
DAX
CALCULATE(
	[Sprzedaż Netto],
	 ALL(dKategorie)
 )
```

---
### REMOVEFILTERS - nowszy odpowiednik ALL

Od 2019 roku mamy `REMOVEFILTERS`, który robi dokładnie to samo co `ALL` w kontekście `CALCULATE`:

```dax
DAX
// Te dwie miary są identyczne:
CALCULATE(
	[Sprzedaż Netto],
	 ALL(dKategorie)
 )
CALCULATE(
	[Sprzedaż Netto],
	 REMOVEFILTERS(dKategorie)
)
```

Dlaczego `REMOVEFILTERS` jest lepszy?

1. Nazwa jasno mówi co robi (usuwa filtry, nie "wszystko")
2. `ALL` ma podwójne znaczenie - jako modyfikator filtra i jako funkcja tabelaryczna
3. Czytelność kodu

```dax
DAX
// ALL jako funkcja tabelaryczna (zwraca tabelę bez filtrów)
All Products Table = ALL(dKategorie)

// ALL jako modyfikator w CALCULATE (usuwa filtry)
fSprzedaż Without Filter = CALCULATE([Sprzedaż Netto], ALL(dKategorie))

// REMOVEFILTERS - jednoznaczne, tylko modyfikator
fSprzedaż Without Filter = CALCULATE([Sprzedaż Netto], REMOVEFILTERS(dKategorie))
```


# ALLEXCEPT 

### Problem, który rozwiązuje ALLEXCEPT

Wyobraź sobie tabelę dKategorie z kolumnami: ProductKey, ProductName, Kategoria, ProductSubcategoryName, BrandName, Color, UnitPrice.

Chcesz policzyć udział produktu w swojej kategorii. Potrzebujesz usunąć filtry z produktu, ale ZACHOWAĆ filtr kategorii.

```dax
DAX
// Podejście 1: wymieniasz wszystko co chcesz usunąć
fSprzedaż Category Total v1 =
CALCULATE(
    [Sprzedaż Netto],
    ALL(
        dKategorie[ProductKey],
        dKategorie[ProductName],
        dKategorie[ProductSubcategoryName],
        dKategorie[BrandName],
        dKategorie[Color],
        dKategorie[UnitPrice]
    )
)
```

Działa, ale jest nieczytelne i łatwo o pomyłkę. A co jeśli ktoś doda nową kolumnę do tabeli?

```dax
DAX
// Podejście 2: ALLEXCEPT
fSprzedaż Category Total v2 =
CALCULATE(
    [Sprzedaż Netto],
    ALLEXCEPT(dKategorie, dKategorie[Kategoria])
)
```

`ALLEXCEPT` mówi: "usuń wszystkie filtry z dKategorie OPRÓCZ filtra na Kategoria".

---
### Wizualizacja działania

Raport pokazuje produkty w kategorii "Computers":

|Produkt|[Sprzedaż Netto]|[fSprzedaż Category Total]|Udział|
|---|---|---|---|
|Laptop A|150 000 zł|400 000 zł|37.5%|
|Laptop B|120 000 zł|400 000 zł|30.0%|
|Desktop C|130 000 zł|400 000 zł|32.5%|

Gdy użytkownik przełączy na kategorię "Cameras":

|Produkt|[Sprzedaż Netto]|[fSprzedaż Category Total]|Udział|
|---|---|---|---|
|Camera X|100 000 zł|250 000 zł|40.0%|
|Camera Y|150 000 zł|250 000 zł|60.0%|

Filtr kategorii jest respektowany - total zmienia się z 400 000 na 250 000.

---
### ALLEXCEPT z wieloma kolumnami

Możesz zachować filtry na wielu kolumnach:

```dax
DAX
// Udział produktu w swojej kategorii I kraju
fSprzedaż Category Country Total =
CALCULATE(
    [Sprzedaż Netto],
    ALLEXCEPT(
        dKategorie,
        dKategorie[Kategoria]
    ),
    ALLEXCEPT(
        dGeography,
        dGeography[RegionCountryName]
    )
)
```


# ALLSELECTED

Masz raport z tabelą pokazującą sprzedaż po kategoriach. Użytkownik wybiera w slicerze trzy kategorie: Computers, Cameras, TV. Chce widzieć udział każdej z tych trzech w ich łącznej sumie.

```dax
DAX
// Próba z ALL
fSprzedaż % with ALL =
DIVIDE(
    [Sprzedaż Netto],
    CALCULATE([Sprzedaż Netto], ALL(dKategorie[Kategoria]))
)
```

Problem: ALL usuwa WSZYSTKIE filtry z kategorii - czyli ignoruje też slicer. Mianownik to sprzedaż wszystkich kategorii w bazie (także Audio, Games, itd.), nie tylko trzech wybranych.

|Kategoria|[Sprzedaż Netto]|Mianownik (ALL)|%|
|---|---|---|---|
|Computers|400 000 zł|2 000 000 zł|20%|
|Cameras|250 000 zł|2 000 000 zł|12.5%|
|TV|350 000 zł|2 000 000 zł|17.5%|
|**Suma**|**1 000 000 zł**||**50%** ← nie sumuje się do 100%!|

---
### ALLSELECTED - rozwiązanie

ALLSELECTED usuwa filtry z wizualizacji (tabeli, wykresu), ale ZACHOWUJE filtry zewnętrzne (slicery, filtry strony/raportu).

```dax
DAX
fSprzedaż % with ALLSELECTED =
DIVIDE(
    [Sprzedaż Netto],
    CALCULATE([Sprzedaż Netto], ALLSELECTED(dKategorie[Kategoria]))
)
```

Teraz mianownik to suma tylko dla kategorii wybranych w slicerze:

|Kategoria|[Sprzedaż Netto]|Mianownik (ALLSELECTED)|%|
|---|---|---|---|
|Computers|400 000 zł|1 000 000 zł|40%|
|Cameras|250 000 zł|1 000 000 zł|25%|
|TV|350 000 zł|1 000 000 zł|35%|
|**Suma**|**1 000 000 zł**||**100%** ✓|

### ALLSELECTED bez argumentów

Możesz użyć ALLSELECTED() bez podawania tabeli/kolumny - wtedy usuwa filtry wizualizacji ze WSZYSTKICH tabel:

```dax
DAX
// Usuwa filtr wizualizacji tylko z kategorii
CALCULATE(
	[Sprzedaż Netto],
	 ALLSELECTED(dKategorie[Kategoria])
 )
```


```dax
DAX
// Usuwa filtr wizualizacji ze wszystkiego (produkty, czas, geografia...)
CALCULATE(
	[Sprzedaż Netto],
	 ALLSELECTED()
 )
```

---
### Porównanie ALL vs ALLSELECTED

```dax
DAX
Sprzedaż Netto = SUM(ffSprzedaż[fSprzedażAmount])

// Ignoruje WSZYSTKO - zawsze pełna baza
Grand Total ALL =
CALCULATE([Sprzedaż Netto], ALL(dKategorie))

// Ignoruje wizualizację, respektuje slicery
Grand Total ALLSELECTED =
CALCULATE([Sprzedaż Netto], ALLSELECTED(dKategorie))
```

Scenariusz: Slicer = "Computers", tabela pokazuje podkategorie:

| PodKategorie | [Sprzedaż Netto] | [Grand Total ALL] | [Grand Total ALLSELECTED] |
| ------------ | ------------- | ----------------- | ------------------------- |
| Laptops      | 200 000 zł    | 2 000 000 zł      | 400 000 zł                |
| Desktops     | 150 000 zł    | 2 000 000 zł      | 400 000 zł                |
| Tablets      | 50 000 zł     | 2 000 000 zł      | 400 000 zł                |
|              |               |                   |                           |

- ALL daje całą bazę (2 mln)
- ALLSELECTED daje sumę dla "Computers" (400k) - respektuje fragmentator


---
# KEEPFILTERS

### Problem: CALCULATE nadpisuje filtry

Domyślnie filtr w CALCULATE **zastępuje** istniejący filtr na tej samej kolumnie:

```dax
DAX
fSprzedaż Computers =
CALCULATE(
    [Sprzedaż Netto],
    dKategorie[Kategoria] = "Computers"
)
```

Co się stanie, gdy użytkownik wybierze w slicerze "Cameras"?

| Kontekst użytkownika | [Sprzedaż Netto] | [fSprzedaż Computers] |
| -------------------- | ------------- | ----------------- |
| (brak filtra)        | 1 000 000 zł  | 400 000 zł        |
| Cameras              | 250 000 zł    | 400 000 zł        |
| Computers            | 400 000 zł    | 400 000 zł        |

Filtr z CALCULATE wygrywa - nadpisuje wybór użytkownika. Czasem tego chcesz, czasem nie.

---
### KEEPFILTERS - przecięcie filtrów

KEEPFILTERS mówi: "nie nadpisuj, tylko znajdź część wspólną".

```dax
DAX
fSprzedaż Computers Keep =
CALCULATE(
    [Sprzedaż Netto],
    KEEPFILTERS(dKategorie[Kategoria] = "Computers")
)
```

Teraz:

|Kontekst użytkownika|[fSprzedaż Computers]|[fSprzedaż Computers Keep]|
|---|---|---|
|(brak filtra)|400 000 zł|400 000 zł|
|Cameras|400 000 zł|**BLANK**|
|Computers|400 000 zł|400 000 zł|

Gdy użytkownik wybiera "Cameras", KEEPFILTERS szuka przecięcia: (Cameras) ∩ (Computers) = zbiór pusty = BLANK.

---
### Praktyczny przypadek dla KEEPFILTERS

Masz raport z podziałem na segmenty klientów. Chcesz pokazać sprzedaż "Premium" tylko gdy użytkownik patrzy na segment Premium (nie na siłę):

```dax
DAX
// Bez KEEPFILTERS - zawsze pokazuje Premium, nawet gdy wybrano "Standard"
fSprzedaż Premium - Wrong =
	CALCULATE([Sprzedaż Netto], dCustomer[Segment] = "Premium")

// Z KEEPFILTERS - pokazuje Premium tylko gdy kontekst to Premium
fSprzedaż Premium - Correct =
CALCULATE([Sprzedaż Netto], KEEPFILTERS(dCustomer[Segment] = "Premium"))
```

---
### Kiedy używać KEEPFILTERS?

Rzadko - ale są scenariusze:

1. Walidacja danych (pokaż wartość tylko gdy kontekst się zgadza)
2. Warunkowe KPI (np. "cel" ma sens tylko dla konkretnego regionu)
3. Unikanie "wyciekania" danych do innych kontekstów

---
# CROSSFILTER

Umożliwia tymczasową zmianę kierunku filtrowania relacji w kontekście danego wyrażenia DAX.
```dax
DAX
CROSSFILTER(<columnName1>, <columnName2>, <direction>)
```

- `Both` — filtrowanie dwukierunkowe (filtry przechodzą w obu kierunkach, domyślnie jest jednokierunkowe).
- `None` — wyłącza filtrowanie między tabelami.
- `OneWay` — jednokierunkowe filtrowanie z Column1 do Column2 (domyślnie).
- `OneWayReverse` — jednokierunkowe filtrowanie z Column2 do Column1.

```dax
DAX
Filtruj w obie strony = 
	CALCULATE(
		[Distinct Count of ProductKey],
		 CROSSFILTER(
			FactInternetfSprzedaż[ProductKey],
			DimProduct[ProductKey],
			Both
		)
	)
```


---
## Zastosowanie

Funkcja CROSSFILTER służy do dynamicznego modyfikowania kierunku przepływu filtru między tabelami w ramach pojedynczej miary lub wyrażenia DAX, bez konieczności zmiany ustawień relacji w modelu danych. Jest szczególnie przydatna, gdy standardowy kierunek filtrowania relacji nie wystarcza do osiągnięcia zamierzonego wyniku analitycznego, ale nie chcemy na stałe zmieniać modelu (np. włączać dwukierunkowego filtrowania wszędzie, co mogłoby pogorszyć wydajność).
![[Pasted image 20251210001950.png]]
**Typowe zastosowania:**

- Tymczasowe włączenie filtrowania dwukierunkowego dla specyficznych obliczeń
- Całkowite wyłączenie filtrowania między tabelami w kontekście danej miary
- Odwrócenie kierunku filtrowania relacji dla konkretnych analiz

---
# USERELATIONSHIP
**USERELATIONSHIP** aktywuje nieaktywną relację między tabelami na czas trwania obliczenia. W modelu Power BI między dwiema tabelami może istnieć wiele relacji, ale tylko jedna może być aktywna domyślnie.

### Typowy scenariusz
Najczęstszy przypadek to tabela faktów z wieloma kolumnami dat powiązanymi z jedną tabelą kalendarza:
```dax
DAX
fSprzedaż
├─ Data Sprzedaży      → 'dKalendarz'[Data] (relacja aktywna)
├─ Data Fakturowania   → 'dKalendarz'[Data] (relacja nieaktywna)
└─ Data Dostawy        → 'dKalendarz'[Data] (relacja nieaktywna)
```

![[Pasted image 20251209193536.png]]

---
## Podstawowa składnia

```dax
DAX
------- Miara używająca domyślnej relacji (Data Zamówienia)
Według Zamówienia = 
    SUM ( fSprzedaż, fSprzedaż[Wartość Netto] )


------- Miara aktywująca relację 
Według Faktury = 
CALCULATE (
    SUMX ( fSprzedaż, fSprzedaż[Wartość Netto] ),
    USERELATIONSHIP ( fSprzedaż[Data Fakturowania], 'dKalendarz'[Date] )
)



------- Miara aktywująca relację
Według Dostawy = 
CALCULATE (
    SUMX ( fSprzedaż, fSprzedaż[Wartość Netto] ),
    USERELATIONSHIP ( fSprzedaż[Data Dostawy], 'dKalendarz'[Date] )
)
```

**Kluczowe zasady:**
- `USERELATIONSHIP` działa tylko wewnątrz `CALCULATE` lub `CALCULATETABLE`
- Pierwszym parametrem jest kolumna z tabeli faktów (strona "wiele")
- Drugim parametrem jest kolumna z tabeli wymiaru (strona "jeden")
- Relacja musi fizycznie istnieć w modelu (być zdefiniowana, choć nieaktywna)