---
type: gaps
---

# ALL vs REMOVEFILTERS

Jaka jest różnica między `ALL` a `REMOVEFILTERS` w kontekście `CALCULATE`?

## Dostępne funkcje
- Brak różnicy - działają identycznie
- ALL usuwa wszystkie filtry, REMOVEFILTERS tylko niektóre
- REMOVEFILTERS jest szybsze
- ALL działa tylko na tabelach, REMOVEFILTERS tylko na kolumnach

## Kod do uzupełnienia

```dax
DAX
-- Te dwie miary są:
CALCULATE([Sprzedaż], ALL(dProduct))
CALCULATE([Sprzedaż], REMOVEFILTERS(dProduct))

Odpowiedź: [SLOT:0]
```

## Poprawne rozwiązanie
Brak różnicy - działają identycznie

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

W kontekście `CALCULATE` funkcje `ALL()` i `REMOVEFILTERS()` działają identycznie - obie usuwają filtry z tabeli lub kolumny. `REMOVEFILTERS()` została wprowadzona w 2019 roku jako bardziej czytelna alternatywa. Zaleca się używać `REMOVEFILTERS()` ze względu na jasność nazwy, ale `ALL()` nadal jest powszechnie stosowane. Różnica jest semantyczna, nie funkcjonalna.

## Wskazówka
Która funkcja jest łatwiejsza do zrozumienia w języku naturalnym? Co to sugeruje o ich funkcjonalności?

---

#  Zachowanie wybranych filtrów

Chcesz usunąć wszystkie filtry z tabeli `dProdukt`, OPRÓCZ filtra na `Kategoria`. Jakiej funkcji użyć?

## Dostępne funkcje
- ALLEXCEPT
- KEEPFILTERS
- REMOVEFILTERSEXCEPT
- ALLBUT

## Kod do uzupełnienia

```dax
DAX
Sprzedaż per Kategoria =
CALCULATE(
    [Total Sprzedaż],
    [SLOT:0](dProdukt, dProdukt[Kategoria])
)
```

## Poprawne rozwiązanie
ALLEXCEPT

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

`ALLEXCEPT()` usuwa wszystkie filtry z podanej tabeli OPRÓCZ (except) wymienionych kolumn. Składnia: `ALLEXCEPT(tabela, kolumna1, kolumna2, ...)`. W tym przypadku `ALLEXCEPT(dProduct, dProduct[ProductCategoryName])` usuwa filtry ze wszystkich kolumn tabeli dProduct poza kategorią - dzięki czemu możesz policzyć sumę dla całej kategorii, ignorując filtry na produkty, marki, kolory itp.

## Wskazówka
Szukasz funkcji, która w nazwie ma wszystkie oprócz (ang. all except). Materiał pokazuje przykład z ProductCategoryName.

---

# Filtry z slicerów

Tworzysz wykres z udziałem procentowym kategorii. Użytkownik wybiera w slicerze 3 kategorie. Chcesz, żeby procenty sumowały się do 100% dla tych 3 wybranych kategorii. Jakiej funkcji użyć?

## Dostępne funkcje
- ALL
- ALLSELECTED
- ALLEXCEPT
- REMOVEFILTERS

## Kod do uzupełnienia

```dax
DAX
Sprzedaż % =
DIVIDE(
    [Całkowita Sprzedaż],
    CALCULATE([Całkowita Sprzedaż], [SLOT:0](dProdukt[Kategoria]))
)
```

## Poprawne rozwiązanie
ALLSELECTED

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

`ALLSELECTED()` usuwa filtry z wizualizacji (wiersze/kolumny wykresu/tabeli), ale ZACHOWUJE filtry zewnętrzne - slicery, filtry strony i raportu. Dzięki temu mianownik uwzględnia tylko kategorie wybrane w slicerze, a procenty sumują się do 100%. `ALL()` usunęłoby też filtr ze slicera, co dałoby niepoprawne wyniki.

## Wskazówka
Szukasz funkcji, która pamięta co użytkownik wybrał (selected) w slicerach, ale ignoruje filtry z samej wizualizacji.

---

# Przecięcie filtrów

Masz miarę ze stałym filtrem NAPOJE. Chcesz, żeby gdy użytkownik wybierze Cameras w slicerze, miara zwróciła BLANK (bo nie ma przecięcia). Jakiej funkcji użyć?

## Dostępne funkcje
- KEEPFILTERS
- INTERSECT
- CROSSFILTER
- FILTERINTERSECT

## Kod do uzupełnienia

```dax
DAX
Sprzedaż Computers Keep =
CALCULATE(
    [Total Sprzedaż],
    [SLOT:0](dProduct[ProductCategoryName] = ″NAPOJE″)
)
```

## Poprawne rozwiązanie
KEEPFILTERS

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

`KEEPFILTERS()` tworzy przecięcie (część wspólną) filtrów zamiast nadpisywania. Gdy użytkownik wybierze Cameras w slicerze, a ty filtrujesz na Computers, przecięcie (Cameras) ∩ (Computers) = ∅ (zbiór pusty) = BLANK. Bez `KEEPFILTERS()` filtr z `CALCULATE` nadpisałby wybór użytkownika i zawsze pokazywałby Computers.

## Wskazówka
Szukasz funkcji, która mówi zachowaj (keep) istniejące filtry i znajdź część wspólną z nowym filtrem.

---

# Kierunek relacji

Jakiej funkcji użyjesz do zmiany kierunku filtrowania relacji między tabelami?

## Dostępne funkcje
- CALCULATE
- CROSSFILTER
- FILTERX
- USERELATIONSHIP
## Kod do uzupełnienia

```dax
DAX
Miara =
CALCULATE(
    [Liczba Zamówień],
    [SLOT:0](
        fSprzedaż[Data Dostawy],
        dKalendarz[Data],
        Both
    )
)
```

## Poprawne rozwiązanie
Zmiany kierunku filtrowania relacji między tabelami

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

`CROSSFILTER()` służy do tymczasowej zmiany kierunku filtrowania relacji między tabelami w kontekście danej miary. Możliwe kierunki to: `Both` (dwukierunkowe), `None` (wyłączone), `OneWay` (domyślnie), `OneWayReverse` (odwrócone). Pozwala to dynamicznie modyfikować przepływ filtrów bez zmiany modelu danych.

## Wskazówka
Both, None, OneWay, OneWayReverse. To parametry określające kierunek czegoś. Czego?

---

# Aktywacja relacji

Masz tabelę sprzedaży z trzema datami: Data Zamówienia (relacja aktywna), Data Wysyłki, Data Dostawy (relacje nieaktywne). Chcesz policzyć sprzedaż według daty wysyłki. Jakiej funkcji użyć?

## Dostępne funkcje
- USERELATIONSHIP
- ACTIVATERELATIONSHIP
- SWITCHRELATION
- RELATEDTABLE

## Kod do uzupełnienia

```dax
DAX
Sprzedaż by Data Dostawy =
CALCULATE(
    [Total Sprzedaż],
    [SLOT:0](
        fSprzedaż[Data Dostawy],
        dKalendarz[Data]
    )
)
```

## Poprawne rozwiązanie
USERELATIONSHIP

## Feedback poprawny
✅ Brawo! Rozwiązanie poprawne!

`USERELATIONSHIP()` aktywuje nieaktywną relację między tabelami na czas trwania obliczenia. Składnia: `USERELATIONSHIP(kolumna_z_tabeli_faktów, kolumna_z_tabeli_wymiaru)`. W modelu może być wiele relacji między tymi samymi tabelami, ale tylko jedna aktywna domyślnie. USERELATIONSHIP pozwala tymczasowo użyć innej relacji bez zmiany modelu.

## Wskazówka
Szukasz funkcji, która mówi użyj relacji (use relationship). Materiał pokazuje przykład z ShipmentDate i DeliveryDate.
