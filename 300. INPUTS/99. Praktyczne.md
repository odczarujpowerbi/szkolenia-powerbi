---
type: teoria
---
# USERELATIONSHIP
## USERELATIONSHIP

Funkcja aktywująca nieaktywne relacje w modelu danych. Działa tylko wewnątrz `CALCULATE()`.

**Składnia**:
`USERELATIONSHIP(**Kolumna1, Kolumna2)`

### **Problem biznesowy**

Tabela Sprzedaż ma wiele dat (Faktura, Sprzedaż, Dostawa), ale tylko jedno aktywne połączenie z Kalendarzem.

Aktywna relacja:`Data Faktury → dKalendarz[Date]`

Przykład zastosowanie `USERELATIONSHIP`:
```dax
DAX
Wykonanie Brutto wg Daty Sprzedaży = 
     CALCULATE(
         SUM(´Sprzedaż´[Wartość Brutto]),
         USERELATIONSHIP(´Sprzedaż´[Data Sprzedaży], dKalendarz[Date])
     )
```

---
### **UWAGA!**

Pamiętaj, aby uprzednio utworzyć relację z pozostałymi datami, czyli:
`Data Sprzedaży → dKalendarz[Date]`
`Data Dostawy → dKalendarz[Date]`
Obie te relacje powinny być **nieaktwyne.**


# CALCULATEDGROUP
## CALCULATEDGROUP

Alternatywne podejście do `USERELATIONSHIP` – zamiast tworzyć osobne miary dla każdego typu daty, tworzysz jedną calculation group, która dynamicznie przełącza aktywną relację w zależności od wyboru użytkownika.

W Calculation Group tworzysz calculation items z wyrażeniami:
```dax
CALCULATE(
    SELECTEDMEASURE(), -- PowerBI automatycznie wstawi tutaj miarę!
    USERELATIONSHIP(´Sprzedaż´[Data Sprzedaży], dKalendarz[Date])
)
```

---
### **Problem biznesowy**
Identyczny jak przy `USERELATIONSHIP`: Tabela Sprzedaż ma wiele dat (Faktura, Sprzedaż, Dostawa), ale tylko jedno aktywne połączenie z Kalendarzem.

**Krok 1**: Utwórz Calculation Group o nazwie **Kontekst Daty**

**Krok 2**: Dodaj calculation items:
```dax
wg Data Fakturowania =
CALCULATE(
    SELECTEDMEASURE()
)
```
```dax
wg Data Sprzedaży =
CALCULATE(
    SELECTEDMEASURE(),
    USERELATIONSHIP(´Sprzedaż´[Data Sprzedaży], dKalendarz[Date])
)
```
```dax
wg Data Dostawy =
CALCULATE(
    SELECTEDMEASURE(),
    USERELATIONSHIP(´Sprzedaż´[Data Dostawy], dKalendarz[Date])
)
```


# Warunkowe kolorowanie
## Formatowanie warunkowe
Miara zwracająca kod koloru na podstawie porównania wartości z normą (średnią miesięczną).
### **Zastosowanie na wykresie słupkowym**
W wizualizacji słupkowej Power BI możesz dynamicznie kolorować słupki na podstawie warunku biznesowego.

**Krok 1**: Utwórz miarę zwracającą kod koloru:
```dax
Sprzedaż powyżej normy (kolor) = 
VAR WartoscBiezacegoMiesiaca = 
    CALCULATE( SUM( ´Sprzedaż´[Wartość Brutto] ) )

VAR SredniaMiesieczna = 
    DIVIDE(
        CALCULATE(
            SUM( ´Sprzedaż´[Wartość Brutto] ), 
            REMOVEFILTERS( dKalendarz ),
            VALUES( dKalendarz[Rok] )
        ),
        CALCULATE( 
            DISTINCTCOUNT( dKalendarz[MiesiacSkr] ),
            REMOVEFILTERS( dKalendarz ),
            VALUES( dKalendarz[Rok] )
        )
    )
RETURN
    IF(
        WartoscBiezacegoMiesiaca < SredniaMiesieczna,
        ”#cacaca”,
        ”#265dd2”
    )
```

---

**Krok 2**: W wizualizacji słupkowej przejdź do formatowania → Kolory słupków → Formatowanie warunkowe → Reguły → Wybierz miarę `Sprzedaż powyżej normy (kolor)`

**Efekt**: Słupki poniżej średniej miesięcznej będą szare (#cacaca), a powyżej średniej – niebieskie (#265dd2).


# Proporcjonalny podział celu
## Proporcjonalny podział celu
Miara rozbija miesięczny cel na poszczególne dni, uwzględniając różną wagę dni roboczych i weekendów/świąt.

### **Jak to działa?**

**Iteracja po datach** - `SUMX` przechodzi przez każdą datę w bieżącym kontekście (dzień, tydzień, miesiąc - w zależności od wizualizacji)

Dla każdej daty:
- Pobiera miesięczny cel z tabeli Targety
- Oblicza sumę wag wszystkich dni w tym miesiącu (dzień roboczy = waga 1, weekend/święto = waga 0.5)
- Sprawdza wagę bieżącego dnia (1 lub 0.5)
- Dzieli miesięczny cel przez sumę wag i mnoży przez wagę bieżącego dnia

**Wynik**:
- Na poziomie dnia: wartość proporcjonalna do wagi (dni robocze dostają 2x więcej niż weekendy)
- Na poziomie total: suma wartości dziennych = dokładnie 100% miesięcznego celu

---

### **Przykład**
- Cel miesięczny: 30 000 zł
- Miesiąc ma 20 dni roboczych (waga 20) + 10 weekendów (waga 5) = suma wag 25
- Dzień roboczy dostanie: `30 000 / 25 × 1 = 1 200 zł`
- Weekend dostanie: `30 000 / 25 × 0.5 = 600 zł`

```dax
Target wg Dni = 
SUMX(
    VALUES( dKalendarz[Date] ),
    VAR CurrentDate = dKalendarz[Date]
    VAR CurrentMonth = EOMONTH( CurrentDate, 0 )
    
    // Pobierz target dla tego miesiąca
    VAR MonthlyTarget = 
        CALCULATE(
            SUM( fCele[Cel] ),
            FILTER(
                ALL( dKalendarz[Date] ),
                EOMONTH( dKalendarz[Date], 0 ) = CurrentMonth
            )
        )
    
    // Policz dni w miesiącu z wagami
    VAR DaysWithWeights = 
        SUMX(
            FILTER(
                ALL( dKalendarz ),
                EOMONTH( dKalendarz[Date], 0 ) = CurrentMonth
            ),
            IF( dKalendarz[CzyDzienRoboczy] = 1, 1, 0.5 )
        )
    
    // Waga dla bieżącego dnia (sprawdź czy ta konkretna data to dzień roboczy)
    VAR CurrentDayWeight = 
        VAR IsDzienRoboczy = 
            CALCULATE(
                MAX( dKalendarz[CzyDzienRoboczy] ),
                dKalendarz[Date] = CurrentDate
            )
        RETURN
            IF( IsDzienRoboczy = 1, 1, 0.5 )
    
    // Dzienna wartość targetu
    VAR DailyTarget = 
        DIVIDE( MonthlyTarget, DaysWithWeights ) * CurrentDayWeight
    
    RETURN DailyTarget
)
````


# Przewalutowanie
## Przewalutowanie

### **Komponenty rozwiązania**

**1. Tabela Waluta**
Tabela niepołączona z modelem, zawierająca wartości walut (np. ”PLN”, ”EUR”). Użytkownik wybiera walutę przez slicer, który filtruje tę tabelę.

**2. Numeric Range `_param_Euro-PLN`**
Pozwala użytkownikowi dynamicznie wybrać kurs wymiany. Numeric Range działa jak przełącznik między różnymi miarami lub wartościami.

---

### **Jak działa miara przewalutowania?**

Miara `Wykonanie Brutto (przewalutowanie)`:
- Sprawdza wybraną walutę z tabeli Waluta
- Jeśli wybrano PLN: mnoży wartość przez kurs z field parametera (dzieli przez 100, bo kurs jest zapisany w groszach/setnych)
- Jeśli wybrano EUR: zwraca wartość oryginalną bez konwersji
```dax
Wykonanie Brutto (przewalutowanie) = 
VAR _waluta = SELECTEDVALUE( Waluta[Waluta] )
RETURN
    IF ( 
        _waluta = ”PLN”,
        [Wykonanie brutto] * ´_param_Euro-PLN´[Kurs Value] / 100,
        [Wykonanie brutto]
    )
```

### **Zastosowanie**
- Użytkownik wybiera walutę (PLN/EUR) przez slicer
- Użytkownik ustawia kurs wymiany przez numeric range parameter
- Miara automatycznie przelicza wartości zgodnie z wyborem